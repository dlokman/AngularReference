

Vscode check .net version
dotnet
dotnet --version

Copilot is better in inline code generation and error fixing in VsCode than in Visual Studio

Vscode Container extension:
https://code.visualstudio.com/docs/devcontainers/containers

In Visual Studio Professional, launchSettings.json:
iisSettings:    Api settings when running as IISEXpress
profiles.http:  Api settings when running as HTTP
profiles.https: Api settings when running as Https (also shows http api call)


Switch http to https in visual studio:
https://www.c-sharpcorner.com/article/switch-http-to-https-in-visual-studio/

VsCode:
Check Vscode Extensions CPU and Memory usage
>Developer: Open Process Explorer

Nuget packages download ranking:
https://www.nuget.org/stats/packages

Testing Frameworks for .Net: https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-dotnet-test



----Github Copilot
Guide: https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/



---.net

To execute Sprocs (More or less take same time)
 Use Dapper as Default to execute sprocs (since can map complex types)*
 Use SqlConnection/SqlCommand/SqlReader when need full control over the query
 Ef Core can also use

 SqlConnection/SqlCommand/SqlReader: Use when need full control over the query
 Ef Core:    linq or execute sprocs via _someContext.Database.SqlQueryRaw<returnClassName>
 Dapper:     mapping to .Net objects (Including complex nested objects).

Automapper: Entities to DTOs

concepts: https://www.scholarhat.com/tutorial/aspnet/asp-net-core-interview-questions

Deep Cloning Libraries          Github Stars (too low?)
DeepCloner             11.8M       518
CloneExtensions         2.6M       113
FastDeepCloner          1.6M       172

Deep Cloning:
https://code-maze.com/csharp-deep-copy-of-object/#:~:text=The%20easiest%20way%20to%20create,copy%20of%20the%20original%20object.


•Data Access: Microsoft.EntityFrameworkCore
•Unit Testing: xunit
•API Development: Swashbuckle.AspNetCore
•HTTP Client: Refit (
•Validation: FluentValidation   <----
•Mapping: AutoMapper Vs Dapper


•HttpClientFactory: Recommended approach for managing HttpClient lifetimes and avoiding socket exhaustion.
builder.Services.AddHttpClient();

•HttpClient Directly: Simple and straightforward, but requires manual management of HttpClient instances.
•Refit: Type-safe REST client that generates implementations from interfaces.
•RestSharp: Flexible and popular library for making HTTP requests.

When to use HttpClient Vs Refit for making api calls
•	Use HttpClient:
•	When you need fine-grained control over HTTP requests and responses.
•	For complex scenarios requiring custom logic and configurations.
•	When you want to avoid additional dependencies.

•	Use Refit:
•	For a declarative and strongly-typed approach to making API calls.
•	When you want to reduce boilerplate code and improve readability.
•	For rapid development and quick setup of API clients.

-------------------------------------------------------------------------------------------------

Copilot is better in inline code generation and error fixing in VsCode than in Visual Studio

Microsoft.EntityFrameworkCore
EF 7.0.13
EF 8.0.2  <-- latest

C#
.NET 7.0: Defaults to C# 11.
.NET 8.0: Defaults to C# 12

ASP.NET Core: The web framework for building web applications and APIs.
.NET 8: The latest version of the unified .NET platform.

Misc: WebApi with .Net core Video Series
https://www.youtube.com/playlist?list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v


AutoMapper maps Entities to DTOs

Be able to execute both Sprocs as well as Linq queries


Call MapSwagger().RequireAuthorization ***to secure*** the Swagger UI endpoints. The following example secures the swagger endpoints:
app.MapSwagger().RequireAuthorization();
https://learn.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-8.0#securing-swagger-ui-endpoints


ProblemDetails Class: https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.problemdetails?view=aspnetcore-8.0
A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807.

Differences between Newtonsoft.Json and System.Text.Json
https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/migrate-from-newtonsoft?pivots=dotnet-9-0#table-of-differences

PascalCase Json
{
  "FirstName": "John",
  "LastName": "Doe",
  "EmailAddress": "john.doe@example.com",
  "PhoneNumber": "123-456-7890"
}

CamelCase Json
{
  "firstName": "John",
  "lastName": "Doe",
  "emailAddress": "john.doe@example.com",
  "phoneNumber": "123-456-7890"
}

Default serializer (serializer/deserializer) used in pre .net core: Newtonsoft.json
New serializer used in .net core: System.Text.Json

pre .net core (eg .net 4.8) the default formatter is Newtonsoft.json. In .net Core, the default formatter is System.Text.Json but can be
changed if needed.

Newtonsoft.json settings
config.Formatters.JsonFormatter.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore;
config.Formatters.JsonFormatter.SerializerSettings.NullValueHandling = Newtonsoft.Json.NullValueHandling.Include;


.Net Core Equivalent using System.Text.Json. don't need to include null values. by default, it will

    //Add Snake case JSON output
    builder.Services.Configure<JsonOptions>(option =>
    {
        options.JsonSerializerOptions.ReferenceHandler = System.Text.Json.Serialization.ReferenceHandler.IgnoreCycles;
        option.JsonSerializerOptions.PropertyNamingPolicy = SnakeCaseNamingPolicy.Instance;
    });


ASP.NET Core MVC supports data exchange in Web APIs using input and output formatters.
Input formatters are used by Model Binding.
Output formatters are used to format responses.

Webapi analyzers inspects controllers annotated with ApiControllerAttribute and identifies actions that don't
entirely document their responses.
https://learn.microsoft.com/en-us/aspnet/core/web-api/advanced/analyzers?view=aspnetcore-8.0

The analyzers are included in the .NET Core SDK. To enable the analyzer in your project, include the IncludeOpenAPIAnalyzers property in the project file:
<PropertyGroup>
 <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
</PropertyGroup>

In C#  if we have the following in csproj file
<Nullable>enable</Nullable>

string myString2 = "Hel.lo";   myString2 is not nullable
myString2 = null; // compiler warning since it was declared as not being nullable. need to declare as string? myString1 = "Hel.lo";

if we don't <Nullable>enable</Nullable> set this then all reference types can be set a null value


If a .csproj project has nullable reference types enabled via <Nullable>enable</Nullable>
this means
This feature allows you to explicitly indicate whether a reference type can be null or not.
When nullable reference types are enabled, the compiler provides warnings if you try to assign null to a non-nullable
reference type or if you fail to check for null before dereferencing a nullable reference type.

nullable reference types is enabled (<Nullable>enable</Nullable> in .csproj)
public string A { get; set; }  => Since property is not nullable, it will get implicit [Required] attribute applied
public string? B { get; set; } => Since property is nullable, it will NOT get implicit [Required] attribute applied

•	Without Nullable Reference Types: The property public string A { get; set; } will not have an implicit [Required] attribute applied. All reference types are treated as if they can be null.
•	With Nullable Reference Types: Non-nullable reference types are implicitly treated as required during model binding and validation in ASP.NET Core.


Ref: https://github.com/dotnet/efcore

Commands:
dotnet run
dotnet build

If the environment isn't set, it defaults to Production

------------------------------------------------------------------------------------------------

Microservices: Need 1 Api. 2 Db connection strings
Minimal API: Use controller based Api as default. Minimal api only use for simple, global url endpoints

Controller Based Apis

Logging - Use Serilog

https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-8.0&tabs=visual-studio#xml-comments

Add folowing to csproj to generate comments in Swagger UI
<PropertyGroup>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
</PropertyGroup>

Special types
The following types are bound without explicit attributes: <===========================================

HttpContext: The context which holds all the information about the current HTTP request or response:
app.MapGet("/", (HttpContext context) => context.Response.WriteAsync("Hello World"));

HttpRequest and HttpResponse: The HTTP request and HTTP response:
app.MapGet("/", (HttpRequest request, HttpResponse response) =>
    response.WriteAsync($"Hello World {request.Query["name"]}"));

CancellationToken: The cancellation token associated with the current HTTP request:
app.MapGet("/", async (CancellationToken cancellationToken) =>
    await MakeLongRunningRequestAsync(cancellationToken));

ClaimsPrincipal: The user associated with the request, bound from HttpContext.User:
app.MapGet("/", (ClaimsPrincipal user) => user.Identity.Name);

Minimal APi
Route  Binding Precedence: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-8.0#binding-precedence


Environments: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/environments?view=aspnetcore-8.0

launchSettings.json is not deployed or included in build. Only for local development

If the "commandName" key has the value "Project", therefore, the Kestrel web server (default cross-platform
web server is launched)

By default the WebApplicationBuilder reads configuration from multiple sources, including:
appSettings.json and appSettings.{environment}.json
Environment variables
The command line

var builder = WebApplication.CreateBuilder(args); => creates WebApplicationBuilder
var message = builder.Configuration["HelloKey"];

---------------------------------------------------------------------------------------------------


Books
Web API Development with ASP.NET Core 8:  https://www.packtpub.com/en-us/product/web-api-development-with-aspnet-core-8-9781804610954
ASP.NET Core 8 and Angular: https://www.packtpub.com/en-us/product/aspnet-core-8-and-angular-9781805129936
Mastering Minimal APIs in ASP.NET Core: https://www.packtpub.com/en-us/product/mastering-minimal-apis-in-aspnet-core-9781803237824
ULTIMATE ASP.NET CORE WEB API <---

------------------------------------------------------------------------------------------------------------

•	Comment a block of code: Ctrl + K, Ctrl + C
•	Uncomment a block of code: Ctrl + K, Ctrl + U

.Net 8.x uses C# 12

C# Language Reference: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/

EFCore Database Providers: https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli

Api invoke:
Either via Swagger  => https://learn.microsoft.com/en-us/training/modules/build-web-api-minimal-api/?source=recommendations
Or View > Other Windows > Endpoints Explorer => https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-8.0&tabs=visual-studio)

Unit Testing - Minimal Api
https://github.com/dotnet/AspNetCore.Docs.Samples/tree/main/fundamentals/minimal-apis/samples/MinApiTestsSample


APi Docs - Microsoft Sourcecode
Tutorials: https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/tutorials/min-web-api/samples
https://github.com/MicrosoftDocs/learn
https://github.com/orgs/MicrosoftDocs/repositories?

nugetpackage ranking: https://www.nuget.org/stats/packages

Popular Nuget Packages:
https://abp.io/blog/Top-10-.NET-Core-Libraries-Every-Developer-Should-Know

Unit Testing: XUnit with Moq
.Net best mapping libraries c#:  AutoMapper Vs Dapper   (Project uses Automapper)
Searialize/Deserialize Json: newtonsoft.json
YamlDotNet =>   YamlDotNet provides low level parsing and emitting of YAML as well as a high level object model similar to XmlDocument. A serialization library is also included that allows to read and write objects from and to YAML streams.
Serilog => Logging library for .Net
ClosedXML =>  ( ClosedXML is a .NET library for reading, manipulating and writing Excel 2007+ (.xlsx, .xlsm) files. It aims to provide an intuitive and user-friendly interface to dealing with the underlying OpenXML API.

Microsoft.Extensions.DependencyInjection (if needed)


https://learn.microsoft.com/en-us/training/modules/build-web-api-minimal-database/5-exercise-use-sqlite-database
EF Core tools: Tools for EF Core perform design-time development tasks. For example, they create migrations, apply migrations, and generate code for a model based on an existing database.
dotnet tool install --global dotnet-ef    (Already installed globally***)
Microsoft.EntityFrameworkCore.Design: Contains all the design-time logic for EF Core to create your database.
dotnet add package Microsoft.EntityFrameworkCore.Design --version 8.0

Refit => The automatic type-safe REST library for .NET Core, Xamarin and .NET
reading and writing CSV files: CsvHelper
Dependency Injection Container: Autofac ??
validation library for .NET: FluentValidation ??:
   Supplemental: FluentValidation.DependencyInjectionExtensions


Swashbuckle is a library that generates beautiful API documentation
Swagger UI, to explore and test API operations
Swagger tools for APi: =>   Its overall functioning depends upon the three primary components, AspNetCore.SwaggerGen, AspNetCore.SwaggerUI and AspNetCore.Swagger. All three work in collaboration to provide JSON and XML-based files containing responses. https://positiwise.com/blog/essential-net-core-libraries-that-every-programmer-should-know
  Swashbuckle.AspNetCore
  Swashbuckle.AspNetCore.SwaggerUI
  Swashbuckle.AspNetCore.Swagger
  Swashbuckle.AspNetCore.SwaggerGen


-------------API Technologies

Microsoft .Net Core - General: https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-8.0 <-----------
(see whole tree)
eg Endpoint Filters: https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0

Fundamenatals****: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/?view=aspnetcore-8.0&tabs=windows
  Dependency Injection
  Configuration Settings in .Net Core: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-8.0
  Handle Errors

Web apps>Advanced: https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0
  Types of Filters

Fluent API Configuration: OnModelCreating() = eg => entity.HasOne(x => x.FeedbackStatus).WithMany(x => x.Feedbacks).HasForeignKey(x => x.FeedbackStatusId);

C#  (.NET Framework 4.8, C# version 7.3 => .Net 8.0, C# version 12)
Unit Testing -> XUnit with Moq


.Net Core General
.Net Core Api - Controller Based Apis
Entity Framework Core
Microservices
Minimal Api
OpenApi/Swagger/SwashBuckle
Docker                      TODO: https://learn.microsoft.com/en-us/training/modules/intro-to-docker-containers/
AWS Tutorials
AWS Deployment
   AWS Account

Helm => Helm Charts helps you define, version, install, share, upgrade, or rollback even the most complex Kubernetes application.


.Net Core - Important topics
 Fundamentals
 Web apps > Advanced > Filters >
 Advanced
 Best practices

 Security and Identity

Entity Framework
 Data Access (Do with Entity Framework)
 Tutorials > Data Access (Only applicable to Razor pages  and MVC? Concepts still apply for APIs?) -If applicable, do with Entity Framework)


Kubernetes - TODO <---- Deploy a microservice container to Kubernetes. Managing Kubernetes
https://learn.microsoft.com/en-us/training/modules/dotnet-deploy-microservices-kubernetes/4-exercise-deploy-to-kubernetes
video for above link (1hr 11min - deploy microservices to kebernetes): https://www.youtube.com/watch?v=oN1g6eApv0g&list=PLlrxD0HtieHhXxWKPzL4o4I1R1WJ70Y6t

Deploying Microservices to Kubernetes; https://www.youtube.com/watch?v=3G7NB4waGbk

Kubernetes Cluster: A Kubernetes cluster is a set of nodes that run containerized applications managed by Kubernetes.
Amazon EKS Cluster: Amazon EKS is a managed Kubernetes service provided by AWS that simplifies running Kubernetes on AWS.


********Sample Api Controllers logic (CRUD Operations with Http status codes)***********
1) Controller Based Api: https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&tabs=visual-studio
Project: C:\Users\dalokman\source\repos\.NetCoreApi-Material\ControllerBasedApi\TodoApi\TodoApi\Controllers\TodoItemsController.cs
2) EF Tutorial: https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/
Project: C:\Users\dalokman\source\repos\.NetCoreApi-Material\EF-Tutorial\mslearn-persist-data-ef-core\ContosoPizza\Controllers\PizzaController.cs


API Design- Best Practices:
https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design

https://versionsof.net/core/

Microservices architecture e-book:
https://dotnet.microsoft.com/en-us/download/e-book/microservices-architecture/pdf

Containerized Docker Application Lifecycle with Microsoft Platform and Tools
https://dotnet.microsoft.com/en-us/download/e-book/microservices-devops/pdf


Books
Web API Development with ASP.NET Core 8:  https://www.packtpub.com/en-us/product/web-api-development-with-aspnet-core-8-9781804610954
ASP.NET Core 8 and Angular: https://www.packtpub.com/en-us/product/aspnet-core-8-and-angular-9781805129936

Mastering Minimal APIs in ASP.NET Core: https://www.packtpub.com/en-us/product/mastering-minimal-apis-in-aspnet-core-9781803237824


****************************************************MicroServices Part 1******************************************************

https://www.youtube.com/watch?v=DFDbh1c9zyE (Nish Anil)
https://www.youtube.com/watch?v=sstOXCQ-EG0

Microsoft Microservices: https://dotnet.microsoft.com/en-us/apps/aspnet/microservices

<------TODO----->
https://www.youtube.com/watch?v=RyHDWlIq6vI (6 years ago but maybe good)  27 min - Done (In relation to microservices ebook)
https://www.youtube.com/watch?v=oN1g6eApv0g&list=PLlrxD0HtieHhXxWKPzL4o4I1R1WJ70Y6t   1hr 26min (Nish Anil) - Good
https://www.youtube.com/watch?v=u80gy8-Wgcs   29min (Kubernetes & Helm) - https://www.youtube.com/watch?v=u80gy8-Wgcs (just help-rest crappy)
https://www.youtube.com/watch?v=IkYt3ggUwbI  (32min) - 6 min => Break monolithic (only good till 9 min)

Module (youtube:dotnet)
  https://www.youtube.com/watch?v=jMDufMYAsmw  (46 min)  - Identifies microservices challenges  - done
  https://www.youtube.com/watch?v=u7MM21aIsqk  (59 min - microservices architecture) - done
  https://www.youtube.com/watch?v=iL3Kxd4Auys  (1hr 30min - microservices communication ) - done
  https://www.youtube.com/watch?v=3G7NB4waGbk  (1hr 11min - Deploying Microservices to Kubernetes)- done
  https://www.youtube.com/watch?v=7kVmb747vfM&t=876s (37 min - Distributed Data) - done

Microservices Tutorial:
  https://dotnet.microsoft.com/en-us/learn/aspnet/microservice-tutorial/intro   - Done
  https://learn.microsoft.com/en-us/training/paths/create-microservices-with-dotnet/?WT.mc_id=friends-0000-NANIL - Done


Microservices- mono-repo vs multi-repo  <---- TODO
https://semaphoreci.com/blog/release-management-microservices

If your microservices are loosely coupled, either a multirepo or a monorepo will work perfectly fine.
Multirepos require more work but provide more autonomy.

However, if your services are somewhat coupled, it’s best to make that relationship explicit by using a monorepo. <-----------------
So, when in doubt, a monorepo can be a safer bet, provided you can live with the tradeoffs. <--------------

- **Monorepo**: If your team is small and you need to frequently make cross-cutting changes.
- **Multi-repo**: If your microservices are highly independent and you have a larger team.

MonoRepo- Code sharing*

Microservices architecture e-book:  -  Done
https://dotnet.microsoft.com/en-us/download/e-book/microservices-architecture/pdf

what are microservices - Done <------------------Good Summary****
https://learn.microsoft.com/en-us/training/modules/dotnet-microservices/2-what-are-microservices

In a microservices architecture, a large application is split up into a set of smaller services.
Each service runs in its own process and communicates with other processes by using protocols like HTTP/HTTPS, WebSocket, or Advanced Message Queuing Protocol (AMQP).
Each microservice implements a specific, end-to-end domain or business capability within a certain context boundary.
Each microservice must be developed autonomously and must be independently deployable
Microservices can be based on different data storage technologies (SQL, NoSQL) and different programming languages
Finally, each microservice should own its related domain data model and domain logic. <--------------

Each Microservice API should point to its own Database eg DB1. A second Microservice API cannot point to the same Database DB1 to
query/update data. Each Microservice API owns its own data. When table changes are needed only that Microservice API models need
to be updated.

Correct sequence to break Monolithic to Microservices is to first break 1 big Database into for instance 5 Databases according to
business functionality. Then we need to create 5 Microservice Apis that will own each of the database


They're small, independent, and loosely coupled.   <------------- Keywords: ***SMALL***, INDEPENDENT, LOOSELY COUPLED
Each microservice has a separate code base that a small development team can manage.
They're deployed independently. A team can update an existing microservice without rebuilding and redeploying the entire application.
They persist their data or the external state in their respective databases.
Unlike in a monolithic architecture, microservices don't share databases. <----------- 1 Microservice per Database
They communicate with each other by using well-defined APIs. Internal implementation details of each service are hidden from other services.

Containerization is an approach to software development in which
an 1) application or service, 2)its dependencies, and its 3) configuration are packaged together as a container image.

We use containerizing to deploy microservices.

Docker is an open-source platform that you can use to automate the deployment of applications as portable, self-sufficient
containers that can run in the cloud or on-premises.

https://www.youtube.com/watch?v=oN1g6eApv0g&list=PLlrxD0HtieHhXxWKPzL4o4I1R1WJ70Y6t
Different Microservices do not share databases

Use Event bus to communicate between Microservice Apis via publish/subscribe
 EventBus |   Raise Event  <==   Microservice Api1 => DB1
 EventBus |                ==>   Microservice Api2 => DB2


Kubernetes
A container orchestrator is a system that automatically deploys and manages containerized apps
1) Can dynamically adjust number of container instances (eg high # of requests)
 C1 => C1 C2 C3
2) Automatically update running instances
3) can restart a container if it crashes or fails(self healing)

why does Kubernetes automatically restart pods that have failed?
-Kubernetes will maintain the system state as defined in the configuration files no matter what

https://www.youtube.com/watch?v=u80gy8-Wgcs (just help-rest crappy)
Helm helps us manage kubernetes application using something called Helm charts.
Helm charts helps you define install and upgrade even the most complex kubernetes application

https://www.youtube.com/watch?v=IkYt3ggUwbI  (32min) - 6 min =>
Break 1 big monolithic database to seperate databases so that each microservice api can target a specific database

UI => API => DB

UI 1 => API 1 => DB1   <---Team A
UI 2 => API 2 => DB2   <---Team B
UI 3 => API 3 => DB3   <---Team C

Microservices do not need to share the same technology stack, libraries or frameworks

pg 34 image
One of the principles of a microservices architecture is to have one database for each microservice. Therefore, when you modernize
your monolithic application into microservices, you must split the monolithic database based on the service boundaries that you
identify.

--------------------

***Ref: https://www.youtube.com/watch?v=DFDbh1c9zyE***
MicroServices are Loosely Coupled (independent)**** (Don't depend on each other)
No 2 services know any implementation or contain reference to the other microservice
A MicroService focuses around specific business functionality
Break a large api into small api based on business problems (not on size)
Owned by independent team. can release a feature without relying on other teams
Independently Deployable
Different MicroServices can deploy to different databses
MicroServices communicate with each other by using well defined Apis
MicroServices can use diff tech stacks (.Net, Java)
Since services are loosely coupled, the data will be duplicated<---


In Monolithic application, the modules are tightly coupled***  (Monolithic Vs Microservices architecture)
Current Project: How much Monolithic?

If you have multiple microservices Apis, how do you run them locally together? Seperately? OR via some Vscode setting

https://localhost:5901
https://localhost:5901/swagger/index.html (out of the box)

***Ref: https://www.youtube.com/watch?v=sstOXCQ-EG0***
Microservices run in a container

Need Docker Desktop to create containers in order to turn api into microservices

Vscode has extension for Docker. creating containers without command line

Docker file contains list of instructions on how to package my application into a container

Docker Build command uses Docker file to create a Docker image
docker build -t mymicroservice .


A Docker container is a runtime instance of a Docker image. When you run an image, Docker creates a container from that image.

The relationship between a Docker image and a Docker container is similar to that of a class to an instance in object-oriented programming.
The image serves as the blueprint (class), and the container is the instantiation of that blueprint (instance).

Docker Hub Repository. Its a image repository. Its Like Github is repository for your code
Docker Hub is a central repository to upload Docker images

Many products, including Microsoft Azure, can create containers based on images in Docker Hub.

DockerHub: https://hub.docker.com/

Need to login to Corp Artifactory. Maybe can't pull/push images out of docker hub.


docker tag name tosomeName

docker push artifactory


after tagging: name & tosomeName
will point to the same docker image

The purpose of the docker tag command is to create a new alias for an existing image by assigning it a tag. Tags are used to identify different versions of the same Docker image in a repository

Push to Artifactory (can only push to docker-local-dev)
docker push someArtifactory:latest

Pull from Artifactory
docker pull someArtifactory:latest

Remove image from Artifactory
docker rmi someArtifactory:latest

docker build -t mymicroservice:1.0 .
docker build => building docker image
-t mymicroservice:1.0 => building image and tagging mymicroservice image as version 1.0
. => where docker file is

Kubernetes is a container orchestration platform. An orchestrator is responsible for running, distributing, scaling,
and healing apps comprised of a collection of containers.

image: dalokman/mymicroservice:latest

imagename:  dalokman/mymicroservice  (had tagged it. original name that points to the same image is mymicroservice
tag (version):  latest

don't put Database files in a container since container can get destroyed and be brought back.
can put database in container but put database files outside and volume map data files


????????
https://aws.amazon.com/tutorials/break-monolith-app-microservices-ecs-docker-ec2/

What is an orchestrator?
An orchestrator is a tool that helps you manage, scale, and maintain a containerized application.

You need to consider the process of organizing, adding, removing, and updating many containers. This process is called container
management

To help with container-management tasks, you can use a container orchestrator. Kubernetes is one such orchestrator

Kubernetes tasks
Self-healing of containers; for example, restarting containers that fail or replacing containers.
Scaling deployed container count up or down dynamically based on demand.
Automating rolling updates and rollbacks of containers.
Managing storage.
Managing network traffic.
Storing and managing sensitive information such as usernames and passwords.

In this exercise, you created a deployment file that described exactly how you wanted the containers to run within Kubernetes.
You then had Kubernetes download the image from Docker Hub and start up the containers.

Need to install kubectl tool and the k3d Kubernetes implementation:


youtube: https://www.youtube.com/watch?v=RyHDWlIq6vI

MicroServices ebook: https://dotnet.microsoft.com/en-us/download/e-book/microservices-architecture/pdf
Referenced Application: https://github.com/dotnet-architecture/eshopOncontainers

To communicate between microservices, need an EventBus like AMQP


Architecting-Cloud-Native-NET-Apps-for-Azure pdf
Recommends UI to call Microservice via API Gateway (NLZ template has Integration with API Gateway). API Gateway acts as a reverse proxy
UI => API Gateway => MicroService

1) API Gateway : Implemented as a web API, it acts as a reverse proxy, routing incoming traffic to the internal microservices.

2) Microservice to Microservice communication can take place via Event Bus (Publish/Subscribe)

3) Distributed Transactions between microservices
While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.

Microservices- mono-repo vs multi-repo  - Done
https://semaphoreci.com/blog/release-management-microservices

Microservices (if multiple) => architectural and operational complexity (dramatically) increase

a)Intro to Microservices: https://www.youtube.com/watch?v=jMDufMYAsmw  (46 min skim)
Microservices Challenges:
1)Decomposing functionality into microservices (DB split => API split => UI split)
2)Increased complexity (eventBus - communicating between micoservices, distributed transactions between microservices)
3)Complexity of Managing many services

b) Modeling Microservices: https://www.youtube.com/watch?v=u7MM21aIsqk
Shows sample microservices project 30min and 39min

Can also have a Monolithic UI, API, DB
and extract a Service to make it microservice so it can be scaled independently. but it'll need its own DB

src
  apigateway
  buildingblocks
  services  (APIs)
    basket
    catalog
      Catalog.API
      Catalog.Domain
      Catalog.Infrastructure
    ordering
      Ordering.API
      Ordering.Domain
      Ordering.Infrastructure.NoSql
      Ordering.Infrastructure.Relational

if have 5 Microservices Api and 1 UI and if the UI consumes all 5 microservices, then you need to run 6 processes on local laptop if you want to run
them in debug mode. Could be slow. 7th process could be API gateway. Other option is to point to Dev Apis but then you can't debug
If you have too many Microservices Apis, running locally for debug purposes could be an issue

Microservices challenges: https://github.com/dotnet/docs/blob/main/docs/architecture/microservices/architect-microservice-container-applications/distributed-data-management.md


c) microservices communication https://www.youtube.com/watch?v=iL3Kxd4Auys  (1hr 30min - microservices communication )

API Gateway example in regards to correlationid that it passes to API

Front-End Clients how communicate with microservices Apis:
1) Direct client communication
2) API Gateway pattern (eg can be a Asp.net Core WebApi) <------ Officially recommended 18min
    (API Gateway should be running on multiple containers)

using either rest http or grpc(gaining popularity)

UI calls API Gateway

API Gateway has below controllers
  BasketGateway.Controller.cs  => calls APi=> Basket.API
  CatalogGateway.Controller.cs => calls APi=> Catalog.API
  OrderGateway.Controller.cs   => calls APi=> Order.API

In Azure, Gateway is provided as a service called Azure Api Management

Message Interaction Types
Query: Client needs response from a service
Command: Client needs a service to perform an action
Event: Service reacts to something that's happened in an another service

Microservices FAQs: https://www.jimmybogard.com/my-microservices-faq/

d) Distributed Data - Transactions in Microservices : https://www.youtube.com/watch?v=7kVmb747vfM&t=876s (37 min)

Materialized View Pattern 6 min
If Microservice A that owns DB1 needs data in DB2 owned by Microservice B. Then we can create a materialized view (copy) for DB2
info and keep it in Microservice A for it to be readily be used. Have some kind of pub/sync mechanism to keep it in synch

Microservices do not support distributed transactions 12min <----------------
Saga pattern can help enforce data consistency across microservices

Transaction between API1 and API2 not supported by default but can be implemented
via Saga pattern
UI => Gateway API => Microservice API 1 => EventBus => Microservice API 2

e) Deploying Microservices to Kubernetes; https://www.youtube.com/watch?v=3G7NB4waGbk  (1hr 11min - )

Kubernetes (K8s)

------------------------------------------------Microservices architecture e-book------------------------------------------------------
Other References Material:
https://relevant.software/blog/microservices-database-management/
https://www.youtube.com/watch?v=tiHKefWOyrY&t=435s
https://www.youtube.com/watch?v=CSAFJNoT34M
https://www.youtube.com/watch?v=a_XMsSNdUQA

https://dotnet.microsoft.com/en-us/download/e-book/microservices-architecture/pdf

No shared Database recommendation per Microsoft
1) pg 34 ebook diagram shared DB: https://dotnet.microsoft.com/en-us/download/e-book/microservices-architecture/pdf
2) https://learn.microsoft.com/en-us/training/modules/dotnet-microservices/2-what-are-microservices

Deadlocks  2:36   https://www.youtube.com/watch?v=tiHKefWOyrY&t=435s

Microservices Best Practices (Every article suggests not to use a shared database. Database per service also overkill (small team and users. complexity will drastically increase) since then services will need to communicate with each other. Best is 1 .Net Core API)
Not even best practice article that suggests using a shared database is acceptable. Rather it categorizes it as an anti-pattern.

https://medium.com/design-microservices-architecture-with-patterns/microservices-database-management-patterns-and-principles-9121e25619f1
A shared database is considered an anti-pattern: https://www.baeldung.com/cs/microservices-db-design

https://www.osohq.com/learn/microservices-best-practices

https://www.techtarget.com/searchdatamanagement/tip/Best-practices-for-managing-data-in-microservices

https://semaphoreci.com/blog/microservices-best-practices






If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.
This would break the microservice lifecycle autonomy.

AWS: 1 Microservice per Database and other patterns for Microservices
https://docs.aws.amazon.com/prescriptive-guidance/latest/modernization-data-persistence/enabling-patterns.html

Database-per-service pattern => 1 Microservice per Database
    If you use the database-per-service pattern, you must deploy the  API composition pattern or the CQRS pattern to implement queries that
    span multiple microservices.
  Use this pattern if
    Loose coupling is required between your microservices.
    Microservices have different compliance or security requirements for their databases.
    More granular control of scaling is required.

  Disadv
   It might be challenging to implement complex transactions and queries that span multiple microservices or data stores.
   You have to manage multiple relational and non-relational databases.
   Your data stores must meet two of the CAP theorem requirements: consistency, availability, or partition tolerance.

Shared-database-per-service pattern =>  Multiple Microservices per Database
   Use this pattern if
      You don't want too much refactoring of your existing code base.
      You enforce data consistency by using transactions that provide atomicity, consistency, isolation, and durability (ACID).
      You want to maintain and operate only one database.
      Implementing the database-per-service pattern is difficult because of interdependencies among your existing microservices.
      You don’t want to completely redesign your existing data layer.



How to query multiple Microservices
  API composition pattern => uses an API composer, or aggregator, to implement a query by invoking individual microservices that own the data.
                           It then combines the results by performing an in-memory join.
  Disdv
       It might not be suitable for complex queries and large datasets that require in-memory joins.
       Your overall system becomes less available if you increase the number of microservices connected to the API composer.
       Increased database requests create more network traffic, which increases your operational costs.


  CQRS pattern => UPdate 1 DB. Raise event to update 2nd DB that is used for read purposes

  Event sourcing pattern

  Saga pattern =>  failure management pattern => transactions


In a microservice-based architecture, the application is built on a collection of services that can be developed, tested, deployed,
and versioned independently.

Another benefit of containerization is scalability. You can scale out quickly by creating new containers for short-term tasks

Docker is an open-source project for automating the deployment of applications as portable, self-sufficient containers that can run on the cloud or on-premises.

Docker image containers can run natively on Linux and Windows. However, Windows images can run only on Windows hosts and Linux images
can run on Linux hosts and Windows hosts (using a Hyper-V Linux VM, so far), where host means a server or a VM.

Container: An instance of a Docker image.

Tag: A mark or label you can apply to images so that different images or versions of the same image (depending on the version number
or the target environment) can be identified.

Repository (repo): A collection of related Docker images, labeled with a tag that indicates the image version.

Registry: A service that provides access to repositories. The default registry for most public images is
Docker Hub (owned by Docker as an organization). eg Azure Container Registry, AWS Container Registry

Alternatively, enterprises can have a private registry on-premises for their own Docker images.

Putting images in a registry lets you store static and immutable application bits, including all
their dependencies at a framework level. Those images can then be versioned and deployed in multiple
environments and therefore provide a consistent deployment unit.

if your production environment is Azure cloud, you probably want to store your images in Azure Container Registry

if your production environment is on-premises, you might want to have an on-premises Docker Trusted Registry

Using .NET Framework Vs Using .NET 7

Use .NET 7, with Linux or Windows Containers, for your containerized Docker server application when:
• You have cross-platform needs. For example, you want to use both Linux and Windows Containers.
• Your application architecture is based on microservices.
• You need to start containers fast and want a small footprint per container to achieve better density or more containers per hardware unit in order to lower your costs.


Use .NET Framework for your containerized Docker server application when:
• Your application currently uses .NET Framework and has strong dependencies on Windows.
• You need to use Windows APIs that are not supported by .NET 7.
• You need to use third-party .NET libraries or NuGet packages that are not available for .NET 7. <----------------


Using third-party .NET libraries or NuGet packages not available for .NET 7
Third-party libraries are quickly embracing .NET Standard, which enables code sharing across all .NET flavors,
including .NET 7. With .NET Standard 2.0 and later, the API surface compatibility across different frameworks
has become significantly larger. Even more, .NET Core 2.x and newer applications can also directly reference
existing .NET Framework libraries (see .NET Framework 4.6.1 supporting .NET Standard 2.0). <-------------------------

WCF <-------
Workflow-related services. Windows Workflow Foundation (WF), Workflow Services (WCF + WF in a single service),
and WCF Data Services (formerly known as ADO.NET Data Services) are only available on .NET Framework. There are
currently no plans to bring them to .NET 7.

You should assume that container images, like processes, have multiple instances or will eventually be killed.

What size should a microservice be? When developing a microservice, size shouldn’t be the important point.
Instead, the important point should be to create loosely coupled services so you have autonomy of development,
deployment, and scale, for each service.

In the microservices approach, each microservice owns its model/data.

As stated previously, the data owned by each microservice is private to that microservice and can only be accessed
using its microservice API.


However, in a microservices-based application, the Product and Basket tables are owned by their respective
microservices.
No microservice should ever include tables/storage owned by another microservice in its own <---------------PG 33
transactions, not even in direct queries,

Databases are private per microservice <---------------
MicroService 1 calls Database 1 (should not call Database 2)
MicroService 2 calls Database 2

A microservice can’t directly access a table in another microservice

To make an update to the Basket microservice, the Catalog microservice should use eventual consistency
 probably based on asynchronous communication such as integration events <--- Check what DevX recommends
(message and event-based communication).

----------------------Microservices calling other Microservices- ***Try to avoid the need. Else will have to use eventbus like AMQP, Polling:Http***----------------------
A microservice can call other microservices
If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response
cycle, you’re creating a chain of HTTP calls.


It’s recommended that you use only ***asynchronous interaction*** for inter-microservice communication, either by using
asynchronous message- and event-based communication, or by using (asynchronous) HTTP polling independently of the
original HTTP request/response cycle. pg 36

If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.

The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that
are part of the end-to-end application are down or unhealthy. I


Synchronous(not recommended) Vs Asynchronous communication (recommended: eventbus like AMQP, Polling:Http) across microservices
see Diagram on pg 51: NET-Microservices-Architecture-for-Containerized-NET-Applications (2)



When deploying an application to a Kubernetes cluster, you can use the original kubectl.exe CLI tool using deployment files
based on the native format (.yaml files), as already mentioned in the previous section.

However, for more complex Kubernetes applications such as when deploying complex microservice-based applications,
it’s recommended to use Helm  <---------------------------------------Helm


A microservice-based solution like this also has some drawbacks:

Distributed application. Distributing the application adds complexity for developers when they are designing and building the
services. For example, developers must implement ***inter-service communication*** using protocols like HTTP or AMQP, which adds
complexity for testing and exception handling. It also adds latency to the system. <--------------------

Transactions are not possible between multiple microservices                       <------------------------
Atomic transactions. Atomic transactions between multiple microservices usually are not possible.

using the code-first approach (that makes it easy to evolve the database as your model changes over time).

automate Swagger metadata generation for ASP.NET Core REST API => using Swashbuckle pg 112

A key point in microservices is that each microservice owns its related data, so it should have its own database. <---------------
pg 34


Simplifying somewhat, the CAP theorem says that you cannot build a (distributed) database (or a microservice
 that owns its model) that’s continually available, strongly consistent, and tolerant to any partition. You must
 choose two of these three properties.
In microservices-based architectures, you should choose availability and tolerance, and you should de-emphasize
 strong consistency.

Unit Testing pg 153 <-----------------------------------

Data Annotations versus Fluent API pg 250

Each microservice has its own database, allowing it to be fully decoupled from other microservices.

Microservices ebook
As stated by the CAP theorem, you need to choose between availability and ACID strong consistency.
Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.
Not applicable to our project.
Scale with high load...microservices

----------------------------------------MicroServices  End-------------------------------------------------------



----------------------------------------Minimal Apis-------------------------------------------------------

***Minimal Apis***

Minimal Api Tutorial:
https://learn.microsoft.com/en-us/training/paths/aspnet-core-minimal-api/  - Done <---- 1hr 35 min (full tutorial- contains 3 new tutorials below)

https://learn.microsoft.com/en-us/training/modules/build-web-api-minimal-api/?source=recommendations  - Done
https://learn.microsoft.com/en-us/training/modules/build-web-api-minimal-database/ (EF Core) - Done
https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-8.0&tabs=visual-studio  - Done

(Filter youtube list after completing tutorial above) <-----------------TODO after going over above tutorials
1) (.Net 7) https://www.youtube.com/watch?v=HXHwtEjQoyM (22min)
10:52 can use .net user job tool to create tokens to test endpoints
dotnet user-jwts create --role "trainer" --claim "permission=admin"

10:01
opts.InferSecuritySchemes = true to show Authorize button in Swagger UI to test endpoints
Endpoint Filters: https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0

2)  (.Net 6) https://www.youtube.com/watch?v=uoVeZzKl6WQ (30min)
3) https://www.youtube.com/watch?v=PJzWsQ0y-X4 (24min - skim?)


Minimal APIs are architected to create HTTP APIs with ***minimal dependencies***. They're ideal for microservices
and apps that want to include only the ***minimum*** files, features, and dependencies in ASP.NET Core.


Minimal API Documentation: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/overview?view=aspnetcore-8.0

The minimal APIs consist of:
 1) WebApplication and WebApplicationBuilder
 2) Route Handlers

Environment variables in .Net Core: https://andrewlock.net/8-ways-to-set-the-urls-for-an-aspnetcore-app/


***how to get services from the DI container during application startup***

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

using (var scope = app.Services.CreateScope())
{
    var sampleService = scope.ServiceProvider.GetRequiredService<SampleService>();
    sampleService.DoSomething();
}
app.Run();


builder.Configuration.GetSection("Forgerock:ClientId").Value

tried to get configuration section from
1) appSettings.json and appSettings.{environment}.json
2) Environment variables
3) The command line


app.MapGet is part of the minimal APIs introduced in .NET 6, <====================
which allows you to define routes and their handlers
directly in the Program.cs file. This approach is useful for simple endpoints or when you want to quickly set up
a route without creating a full controller.

You can combine both approaches in the same application. For example, you might use app.MapGet for simple,
standalone endpoints and controllers for more complex, organized APIs.

copilot:
While minimal APIs are great for simple, lightweight scenarios, controller-based APIs offer more advanced features and capabilities that are
beneficial for more complex applications. If your application requires complex routing, model binding, validation, filters, structured
dependency injection, or versioning, a controller-based approach might be more suitable.

Can mix and match. Controllers would inherit from ControllerBase but can still have app.Mapget in Program.cs for simple
apis

Difference between minimal api app.MApget Vs Controllers
app.MapGet: Useful for quickly setting up simple routes directly in the Program.cs file. Ideal for minimal APIs or
            simple endpoints.
Controllers: Provide a structured way to organize complex APIs with multiple actions, leveraging features
             like model binding, validation, and filters <===========================


Controller Based Apis are more feature rich when it comes to Model Validation and Model Binding. Use that
for regular routes. Use app.mapGet use for simple routes. Can use both <---------------------

Controller-based APIs provide more advanced and flexible model binding and validation features, making them suitable for
more complex applications. Minimal APIs are simpler and more lightweight, ideal for small, focused endpoints or
microservices.

MapGroup: The MapGroup extension method helps organize groups of endpoints with a common prefix.
It reduces repetitive code and allows for customizing entire groups of endpoints with a single call
to methods like RequireAuthorization and WithMetadata which add endpoint metadata.


The HTTP methods GET, HEAD, OPTIONS, and DELETE don't implicitly bind from body.Have to bind explicitly and specify
[FromBody]. POST can bind implicitly

C# record type:
A record data type is particularly useful in scenarios where you need to encapsulate data and ensure that instances
are compared based on their values rather than their references. One common use case is representing immutable data
transfer objects (DTOs) or entities in a domain model.
•Immutability: Ensures that the data cannot be changed after it is created, which is useful for thread safety and maintaining data integrity.
•Value-Based Equality: Simplifies comparisons and ensures that two records with the same data are considered equal.
(as opposed to checking object references)


Explicit Parameter Binding
app.MapGet("/{id}", ([FromRoute] int id,
                     [FromQuery(Name = "p")] int page,
                     [FromServices] Service service,
                     [FromHeader(Name = "Content-Type")] string contentType)
                     => {});

The [FromForm] attribute binds form value

Parameter binding for minimal APIs binds parameters through dependency injection when the type is configured as a service.
It's not necessary to explicitly apply the [FromServices] attribute to a parameter. I

Optional Parameter:          string ListProducts(int? pageNumber)
Default value for Parameter: string ListProducts(int pageNumber = 1)

https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-8.0#special-types

Special types
The following types are bound without explicit attributes: <===========================================

HttpContext: The context which holds all the information about the current HTTP request or response:
app.MapGet("/", (HttpContext context) => context.Response.WriteAsync("Hello World"));

HttpRequest and HttpResponse: The HTTP request and HTTP response:
app.MapGet("/", (HttpRequest request, HttpResponse response) =>
    response.WriteAsync($"Hello World {request.Query["name"]}"));

CancellationToken: The cancellation token associated with the current HTTP request:
app.MapGet("/", async (CancellationToken cancellationToken) =>
    await MakeLongRunningRequestAsync(cancellationToken));

ClaimsPrincipal: The user associated with the request, bound from HttpContext.User:
app.MapGet("/", (ClaimsPrincipal user) => user.Identity.Name);

duplicate form boolean value sent example:
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-8.0#bind-to-collections-and-complex-types-from-forms

combine parameters to an object using [AsParameters]
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-8.0#parameter-binding-for-argument-lists-with-asparameters

Minimal APi
Route  Binding Precedence: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-8.0#binding-precedence

Reads Cors.Enabled from appsettings.json file
if (app.ApplicationServices.GetRequiredService<IOptions<CorsOptions>>().Value.Enabled)

Send back Json result
app.MapGet("/hello", () => Results.Json(new { Message = "Hello World" }));


WriteAsJsonAsync is an alternative way to return JSON:
app.MapGet("/", (HttpContext context) => context.Response.WriteAsJsonAsync(new { Message = "Hello World" }));

return File: app.MapGet("/download", () => Results.File("myfile.text"));


Filters in Minimal API apps
1) Endpoint filter example
2) filter order sequence
3) Validate an parameter with a filter
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/min-api-filters?view=aspnetcore-8.0

Minimal API filters allow developers to implement business logic that supports:
Running code before and after the endpoint handler.
Inspecting and modifying parameters provided during an endpoint handler invocation.
Intercepting the response behavior of an endpoint handler.


return Results.Problem("Red not allowed!");
By default, this method returns a response with a status code of 500 Internal Server Error.


var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
string ColorName(string color) => $"Color specified: {color}!";
app.MapGet("/colorSelector/{color}", ColorName)
    .AddEndpointFilter(async (invocationContext, next) =>
    {
        var color = invocationContext.GetArgument<string>(0);

        if (color == "Red")
        {
            return Results.Problem("Red not allowed!");
        }
        return await next(invocationContext);
    });

app.Run();

Authentication and authorization in minimal APIs: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/security?view=aspnetcore-8.0
Authentication is the process of determining a user's identity.
Authorization is the process of determining whether a user has access to a resource.

2 types of Authorizations:

Role-based strategies determine a user's access based on the role they are assigned, such as Administrator or User.
For more information on role-based authorization, see role-based authorization documentation.

Claim-based strategies determine a user's access based on claims that are issued by a central authority.
For more information on claim-based authorization, see claim-based authorization documentation.


Use dotnet user-jwts for development testing
dotnet user-jwts create

JWT bearer-based authentication requires that clients present a token in the request header to validate their identity and
claims. Typically, these tokens are issued by a central authority, such as an identity server.

When developing on the local machine, the dotnet user-jwts tool can be used to create bearer tokens.

For example, to create a token for the admin role and greetings_api scope expected by the authorization policy in the preceding code:
dotnet user-jwts create --scope "greetings_api" --role "admin"

The generated token can then be sent as part of the header in the testing tool of choice. For example, with curl:
curl -i -H "Authorization: Bearer {token}" https://localhost:{port}/hello


----------------------------------------------OPenApi TODO------------------------------------------



Microsoft .Net Core - General: https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-8.0 <-----------
(see whole tree)
eg Endpoint Filters: https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0

Fundamenatals****: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/?view=aspnetcore-8.0&tabs=windows
  Dependency Injection
  Configuration Settings in .Net Core: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-8.0
  Handle Errors

----------------------------------------Minimal Api End-------------------------------------------------------

****.Net Core Api****

Tutorials <----------------------TODO
https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&tabs=visual-studio   - Done
https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-mongo-app?view=aspnetcore-8.0&tabs=visual-studio
https://learn.microsoft.com/en-us/aspnet/core/tutorials/web-api-javascript?view=aspnetcore-8.0
https://learn.microsoft.com/en-us/aspnet/core/tutorials/publish-to-azure-api-management-using-vs?view=aspnetcore-8.0

.Net Core Api: https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0 <-- TODO

Tutorial .Net Core with Angular
https://learn.microsoft.com/en-us/visualstudio/javascript/tutorial-asp-net-core-with-angular?view=vs-2022


Microsoft .Net Core - Api - Main website: https://dotnet.microsoft.com/en-us/apps/aspnet/apis <------ Done

Microsoft .Net Core - Api Docs: https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-8.0  <----TODO Go Over All

Microsoft .Net Core - General: https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-8.0 <-----------
(see whole tree)
eg Endpoint Filters: https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0
Dependency Injection

https://www.youtube.com/watch?v=qBTe6uHJS_Y
https://www.youtube.com/@TeddySmithDev/videos (32 videos)
https://www.youtube.com/watch?v=E6sUJWwZLwE

https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-8.0&WT.mc_id=dotnet-35129-website
https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-8.0&tabs=visual-studio
https://learn.microsoft.com/en-us/shows/dotnetconf-2023/minimal-api-spa-a-perfect-match


***SwashBuckle/Swagger/OpenApi***
https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-8.0&tabs=visual-studio
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-8.0
Swagger is used to generate useful documentation and help pages for web APIs.

Scott Hanselman
https://www.hanselman.com/blog/category/dotnetcore
https://www.hanselman.com/blog/category/aspnet-web-api


Youtube:
https://www.youtube.com/watch?v=DFDbh1c9zyE
https://www.youtube.com/watch?v=E6sUJWwZLwE
https://www.youtube.com/watch?v=qBTe6uHJS_Y
https://www.youtube.com/@TeddySmithDev/videos  (32 videos)


Reference:
https://www.yogihosting.com/category/aspnet-core/

Restful Api: https://medium.com/@chandrashekharsingh25/build-a-restful-web-api-with-net-8-44fc93b36618


******Entity Framework*****

TODO: https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/3-migrations <--------- Done
EF Tutorial: https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/      <--------- Done


EntityFramework: https://learn.microsoft.com/en-us/ef/
EntityFrameworkCore: https://learn.microsoft.com/en-us/ef/core/

Data Access Tutorials using API???  Only see for Razor and MVC. Applicable??? <-----------------------

check:  For local development, use Secret Manager
Project: C:\Users\dalokman\source\repos\.NetCoreApi-Material\EF-Tutorial\mslearn-persist-data-ef-core\ContosoPizza


EF videos
5 videos: https://learn.microsoft.com/en-us/shows/entity-framework-core-101/?wt.mc_id=educationalef-c9-niner
Getting Started with Entity Framework Core: https://www.youtube.com/watch?v=SryQxUeChMc
Working with an Existing Database: https://www.youtube.com/watch?v=DCYVfLT5_QI
ASP.NET Core Web Apps with EF Core: https://www.youtube.com/watch?v=c-wN-fc594c
Database Providers: https://www.youtube.com/watch?v=moRmKo3nrN4
Performance Tips: https://www.youtube.com/watch?v=jgESld7U5Bw




C#:
Doc => https://learn.microsoft.com/en-us/dotnet/csharp/
Videos => https://www.youtube.com/playlist?list=PLdo4fOcmZ0oVxKLQCHpiUWun7vlJJvUiN

Misc: WebApi with .Net core Video Series
https://www.youtube.com/playlist?list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v
https://learn.microsoft.com/en-us/shows/back-end-web-development-with-dotnet-for-beginners/

**************Logging*****************
https://congenial-chainsaw-766b3879.pages.github.io/logging/overview/


*************Docker tutorial - TODO**********************
https://learn.microsoft.com/en-us/training/modules/intro-to-docker-containers/

**************AWS Tutorials- Done*****************

Setting Up Your AWS Environment - Done
https://aws.amazon.com/getting-started/guides/setup-environment/?ref=gsrchandsons

Talk about mono-Repo Vs multi-Repo for microservices****
During the process, another question arises: whether to use a single (mono) repository for all microservices or to keep each
microservice in its own repository. <-----------------------------------
Using a repository for each microservice has several benefits <----Recommends keeping each microservice in its own repository
Facilitating faster software release
Enabling the creation of smaller teams to develop and deliver a single service
Allowing the team to maintain a smaller codebase, reducing complexity
Allowing for faster build and deployment processes with a smaller codebase
Allowing for the freedom to write code independently and differently from all other services (using different programming languages, libraries, approaches, etc)

Splitting a Monolith into containerized microservices, and set up CI/CD pipelines for them using AWS Copilot
https://community.aws/content/2djhTaf6woZwSQPAEt94ScYWWDv/ci-cd-pipelines-for-two-connected-services-using-aws-copilot


Deploy a Container Web App on Amazon EKS - Skimmed
https://aws.amazon.com/tutorials/deploy-webapp-eks/

Break a Monolithic Application into Microservices with AWS Copilot, Amazon ECS, Docker, and AWS Fargate: - Skimmed
https://aws.amazon.com/tutorials/break-monolith-app-microservices-ecs-docker-ec2/




---Later do if needed---

Automatically Manage DNS Records for Your Microservices in Amazon EKS with ExternalDNS:
https://community.aws/content/2dxHaSe8R2Kpzqt1wvFMqM5PyLl/navigating-amazon-eks-automating-dns-records-for-microservices-using-externaldns

Deploy an ASP.NET Core Application on Windows Server with AWS Lightsail
https://community.aws/content/2iCmSOFCudFKCqKuxtAigP6Aorq/practical-cloud-guide-deploy-an-asp-net-core-application-on-windows-server-with-aws-lightsail


Ref:
Migrate a SQL Server Database to the Cloud
https://community.aws/content/2iCm0wdEAYgUOaRMLhBqKCmZUw1/practical-cloud-guide-migrate-a-sql-server-database-in-the-cloud

Bootstrapping your Terraform automation with Amazon CodeCatalyst
https://community.aws/content/2dy0xjEZtBOuAfGLNP9QNfXz89T/bootstrapping-terraform-automation-amazon-codecatalyst

Automating Multiple Environments with Terraform
https://community.aws/content/2dusdtfA7noWlDe8xPB0xFT8ILU/automating-multiple-environments-with-terraform

Building an Amazon EKS Cluster Preconfigured to Run High Traffic Microservices
https://community.aws/content/2dr1uEC9C5CEKgiLUFY6fKRL5yo/navigating-amazon-eks-eks-cluster-high-traffic

how to Deploy Your Microservice to aws eks


-----------------------------------------------------------------Notes--------------------------------------------------------------------

Copilot command: Highlight Json in Api project and prompt copilot 'Generate C# types from the following json'
Copilot will create C# classes from the Json.

https://learn.microsoft.com/en-us/shows/dotnetconf-2023/minimal-api-spa-a-perfect-match


-----------------------------------------------Kubernetes---------------------------------------------------------

A Kubernetes (k8s) cluster is a set of nodes that run containerized applications managed by Kubernetes. Kubernetes is an open-source platform designed to automate deploying, scaling, and operating application containers. Here’s a breakdown of the key components and concepts:

### Key Components of a Kubernetes Cluster

1. **Master Node**: The master node is responsible for managing the Kubernetes cluster. It runs several key components:
   - **API Server**: Exposes the Kubernetes API.
   - **Scheduler**: Assigns workloads to nodes based on resource availability.
   - **Controller Manager**: Ensures the desired state of the cluster by managing controllers.
   - **etcd**: A distributed key-value store used for storing cluster data.

2. **Worker Nodes**: These nodes run the containerized applications. Each worker node contains:
   - **Kubelet**: An agent that ensures containers are running in a Pod.
   - **Kube-proxy**: Manages network rules and load balancing.
   - **Container Runtime**: Software responsible for running containers (e.g., Docker, containerd).

3. **Pods**: The smallest deployable units in Kubernetes, which can contain one or more containers. Pods share the same network namespace and storage.

4. **Services**: Abstractions that define a logical set of Pods and a policy by which to access them. Services enable load balancing and service discovery.

5. **Deployments**: Provide declarative updates to Pods and ReplicaSets. They manage the desired state of application deployment.

6. **ConfigMaps and Secrets**: Used to manage configuration data and sensitive information, respectively.

### How a Kubernetes Cluster Works

1. **Deployment**: You define the desired state of your application using YAML or JSON configuration files. This includes the number of replicas, container images, and other settings.

2. **Scheduling**: The Kubernetes scheduler assigns Pods to nodes based on resource requirements and availability.

3. **Scaling**: Kubernetes can automatically scale applications up or down based on resource usage or custom metrics.

4. **Self-Healing**: Kubernetes automatically replaces or reschedules Pods that fail, are terminated, or are unresponsive.

5. **Networking**: Kubernetes provides a flat network structure, allowing all Pods to communicate with each other. Services provide stable IP addresses and DNS names for Pods.

6. **Storage**: Kubernetes abstracts storage resources, allowing you to use local storage, network storage, or cloud-based storage solutions.

### Benefits of Using Kubernetes

- **Scalability**: Easily scale applications horizontally by adding more Pods.
- **High Availability**: Ensures applications are always running and can recover from failures.
- **Portability**: Run applications consistently across different environments (on-premises, cloud, hybrid).
- **Resource Efficiency**: Optimizes resource usage by scheduling workloads based on available resources.
- **Automation**: Automates deployment, scaling, and management of containerized applications.

### Example Use Case

Imagine you have a microservices-based application with multiple services (e.g., user service, order service, payment service). Each service can be containerized and deployed as a Pod in a Kubernetes cluster. Kubernetes manages the deployment, scaling, and networking of these services, ensuring they are always available and can communicate with each other.

### Conclusion

A Kubernetes cluster is a powerful tool for managing containerized applications at scale. It abstracts the complexity of deploying and managing containers, providing a robust and flexible platform for modern application development and operations.


------------------------------------------------Minimal APIs------------------------------------------

A minimal API is created using 'dotnet new web'

Minimal APIs are architected to create HTTP APIs with minimal dependencies. They're ideal for microservices and apps that
want to include only the minimum files, features, and dependencies in ASP.NET Core


Minimal API
For small, simple applications or microservices.
smaller APIs or microservices. They are ideal for small applications
Missing some features available to Controller Based API
A minimal API differs from a controller-based API because you explicitly specify the routes you need instead of relying
on a convention-based approach like with a controller-based API.

Controller Based API <-- use AddControllers in Program.cs => The template for the controller-based web API wires up the controllers using the AddControllers method.
For bigger applications. Structure
1)
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();

2)
var app = builder.Build();
app.MapControllers();



Controller methods are moved to Program.cs. Routing & Methods are defined within Program.cs or Startup.cs file

Minimal APIs are a simplified approach for building fast HTTP APIs with ASP.NET Core

Dependency Injection Different
Minimal APIs support dependency injection through other approaches such as accessing the service provider.

Idea
You can build *fully functioning REST endpoints* with ***minimal code and configuration***
Skip *traditional scaffolding* and avoid *unnecessary controllers* ******by fluently declaring API routes and actions******

ASP.NET Core supports two approaches to creating APIs: a controller-based approach and minimal APIs.

controller-based
Controllers in an API project are classes that derive from ControllerBase

There are a few capabilities available with controller-based APIs that are not yet supported or implemented by minimal APIs. These include:
No built-in support for model binding (IModelBinderProvider, IModelBinder). Support can be added with a custom binding shim.
No built-in support for validation (IModelValidator).
No support for application parts or the application model. There's no way to apply or build your own conventions.
No built-in view rendering support. We recommend using Razor Pages for rendering views.
No support for JsonPatch
No support for OData


The template for the controller-based web API wires up the controllers using the AddControllers method.

1. Console Application:
dotnet new console

2. Class Library:
dotnet new classlib

3. ASP.NET Core Web Application:
dotnet new web

4. ASP.NET Core Web API:
dotnet new webapi

5. ASP.NET Core MVC Application:
dotnet new mvc


Swagger implements the OpenAPI specification. This format describes your routes but also what data they accept and produce. '
Swagger UI is a collection of tools that render the OpenAPI specification as a website and let you interact with your API
via the website.

Note that Swagger should be limited to development time, as it can be a security risk if it's available in production.

nuget packages are stored in C:\Users\dalokman\.nuget\packages so we can share among projects

HTTP 5000 to 5300.
HTTPS has a port selected for it in the range of 7000 to 7300.

Task<List<string>> => 	Task is a type provided by the .NET framework that represents an asynchronous operation. It is part of the System.Threading.Tasks namespace.
This represents an asynchronous operation that, when completed, will return a List<string>.

public async Task<List<string>> GetNamesAsync()
{
    await Task.Delay(1000); // Simulate an asynchronous operation
    return new List<string> { "Alice", "Bob", "Charlie" };
}


return Results.Created($"/pizza/{pizza.Id}", pizza);   (Creates statuscode 201 created response)
return Results.NotFound();                             (Creates statuscode 404 not found response)
Results.NoContent();                                   (Creates statuscode 204 No Content response)
return Results.Ok();                                   (Creates statuscode 200 Ok response)


app.MapPut("/todoitems/{id}", async (int id, Todo inputTodo, TodoDb db) =>
{
    var todo = await db.Todos.FindAsync(id);

    if (todo is null) return Results.NotFound();

    todo.Name = inputTodo.Name;
    todo.IsComplete = inputTodo.IsComplete;

    await db.SaveChangesAsync();

    return Results.NoContent();
});

According to the HTTP specification, a PUT request requires the client to send the entire updated entity,
not just the changes. To support partial updates, use HTTP PATCH. <-----------------------------------

TypedResults vs Results (TypedResults helps in Testing)
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses?view=aspnetcore-8.0#typedresults-vs-results
https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-8.0&tabs=visual-studio (example)

Extension Methods: C#
Certainly! An extension method in C# allows you to add new methods to existing types without modifying their source code.
Extension methods are static methods defined in static classes, and they use the this keyword as the first parameter to
specify the type they extend.


Extension Method Example

using System.Globalization;

namespace MyExtensions
{
    public static class StringExtensions   => **See below why this is needed since its not used when ToTitleCase is invoked
    {
        public static string ToTitleCase(this string str)  => this parameter notifies us that string class is being extended
        {
            if (string.IsNullOrEmpty(str))
                return str;

            TextInfo textInfo = CultureInfo.CurrentCulture.TextInfo;
            return textInfo.ToTitleCase(str.ToLower());
        }
    }
}

**Wrapping extension methods in a static class is a requirement in C# to ensure proper scoping, organization, and static
context. It helps manage namespaces, avoid conflicts, and maintain code readability and maintainability. The static class
serves as a container for the extension methods, making them accessible and logically grouped.


Call extension method

using System;
using MyExtensions; // Import the namespace containing the extension method

class Program
{
    static void Main()
    {
        string example = "hello world from github copilot";
        string titleCase = example.ToTitleCase(); // Call the extension method
        Console.WriteLine(titleCase); // Output: "Hello World From Github Copilot"
    }
}



Give me a reason why we would use IApplicationBuilder instead of WebApplication for extension method parameter

namespace xxx;   no curly braces applies to the entire file


Tutorial
Tutorial: Create an ASP.NET Core app with Angular in Visual Studio
https://learn.microsoft.com/en-us/visualstudio/javascript/tutorial-asp-net-core-with-angular?view=vs-2022

You can add a WCF Web Service reference via Connected Services > Service Reference

Visual Studio: Connected Services > Add a Service Dependency Vs Add a Service Reference
https://devblogs.microsoft.com/dotnet/generating-http-api-clients-using-visual-studio-connected-services/

OpenAPI Specification
The OpenAPI Specification (OAS) defines a standard, ***language-agnostic*** interface to HTTP APIs ***which allows both humans and computers to
discover and understand the capabilities of the service*** ****without access to source code***, documentation, or through network traffic inspection.

Example OpenAPI Specification: https://editor.swagger.io/



public async Task<ActionResult<IEnumerable<TodoItem>>> GetTodoItems()

1.  ActionResult:
•	ActionResult is a type provided by ASP.NET Core that represents the result of an action method.
•	It allows you to return various HTTP status codes and content types from your controller actions. <---

2.  Task: Indicates that the method is asynchronous.

3) Hovering over GetTodoItems() shows return type as Task<List<TodoItem>>


_context.Entry(todoItem).State = EntityState.Modified;
•Change Tracking: Entity Framework Core uses change tracking to keep track of the state of entities. By explicitly setting the state to Modified, you inform the context that this entity should be updated in the database.


EntityFramework Change Tracking
• Entity Framework Core uses a change tracker to keep track of the state of entities. The state can be Added, Modified, Deleted, Unchanged,
or Detached.


Controller with Views  (actions are methods defined in a controller that handle incoming HTTP requests)
Route Template: [controller]/[action]
/home/index


API Controllers
Route Template: [controller]
 /todoitems

The route template usually does not include [action] because the HTTP method (GET, POST, PUT, DELETE) is used to determine the action.

nameof(GetTodoItem) gets name of GetTodoItem method. This avoid hardcoding strings. C# nameof keyword is used to avoid hard-coding
the action name in the CreatedAtAction call.

The nameof operator in C# is a compile-time feature that returns the name of a variable, type, or member as a string.
nameOf variable, method, class, property etc

   int myVariable = 10;
   string variableName = nameof(myVariable); // "myVariable"
   void MyMethod() { }
   string methodName = nameof(MyMethod); // "MyMethod"
   class MyClass { }
   string className = nameof(MyClass); // "MyClass"
   class MyClass
   {
       public int MyProperty { get; set; }
   }
   string propertyName = nameof(MyClass.MyProperty); // "MyProperty"

https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&tabs=visual-studio
According to the HTTP specification, a PUT request requires the client to send the entire updated entity, not just the changes. To support partial updates, use HTTP PATCH.

On Put
try {
   await _context.SaveChangesAsync(); // update some item
}
catch (DbUpdateConcurrencyException)
DbUpdateConcurrencyException =>
Exception thrown by DbContext when it was expected that SaveChanges for an entity would
result in a database update but in fact no rows in the database were affected.
Could happen
1) If the item does not exist in database

DTO
Currently the sample app exposes the entire TodoItem object. Production apps typically limit the data that's input and returned
using a subset of the model. There are multiple reasons behind this, and security is a major one. The subset of a model is usually
referred to as a Data Transfer Object (DTO), input model, or view model. DTO is used in this tutorial.

Lambda Expression:
The => symbol is used to define a lambda expression. In this context, it simplifies the method definition to a single expression.

function
public int Add(int a, int b)
{
    return a + b;
}

lambda expression
public int Add(int a, int b) => a + b;


With connected Services you can connect to:
-OpenAPI endpoints
-Windows Communication Foundation (WCF) endpoints

-Databases and data providers

-Azure services
-gRPC (Remote Procedure Call) endpoints

Ref: https://learn.microsoft.com/en-us/visualstudio/azure/overview-connected-services?view=vs-2022

OpenAPI specification was previously called Swagger specification
It is a language-independent standard for describing HTTP APIs.


----------------------------------------------Microservices architecture e-book End------------------------------------------------------


-------------------------------------------------EventBus Vs Kafka-------------------------------------------------------

how does kafka compare with eventbus in terms of publisher/subscriber? what is the usecase for each? for instance eventbus can be used to communicate between microservices



Apache Kafka and EventBus are both used for event-driven communication, but they have different architectures, features, and use cases. Here's a comparison of Kafka and EventBus in terms of publisher/subscriber models and their typical use cases:

Apache Kafka
Publisher/Subscriber Model
Publishers: In Kafka, publishers are called producers. Producers send messages to Kafka topics.
Subscribers: Subscribers are called consumers. Consumers read messages from Kafka topics.
Topics: Kafka topics are partitioned and replicated across multiple brokers, providing scalability and fault tolerance.
Consumer Groups: Kafka supports consumer groups, where multiple consumers can work together to consume messages from a topic. Each message is delivered to only one consumer in the group.
Use Cases
Real-Time Data Streaming: Kafka is ideal for real-time data streaming applications, such as log aggregation, real-time analytics, and monitoring.
Event Sourcing: Kafka can be used to capture changes to application state as a sequence of events, providing a reliable event store.
Data Integration: Kafka can integrate data from various sources into a central data store, acting as a data pipeline.
Microservices Communication: Kafka can be used for asynchronous communication between microservices, especially when high throughput and fault tolerance are required.

EventBus
Publisher/Subscriber Model
Publishers: In EventBus, publishers send events to the EventBus.
Subscribers: Subscribers register to listen for specific events on the EventBus.
Event Handling: EventBus typically uses in-memory event handling, which may not be as scalable or fault-tolerant as Kafka.
Simplicity: EventBus is often simpler to set up and use, making it suitable for lightweight event-driven communication.
Use Cases
Microservices Communication: EventBus is commonly used for communication between microservices within the same application or service boundary. It is suitable for lightweight, low-latency communication.
In-Memory Event Handling: EventBus is ideal for scenarios where events do not need to be persisted or replicated, such as UI event handling or simple inter-service communication.
Local Event Handling: EventBus can be used for local event handling within a single application or service, providing a simple way to decouple components.

Comparison Summary
Scalability: Kafka is highly scalable, supporting large volumes of data and high throughput. EventBus is typically less scalable and is more suitable for lightweight, in-memory event handling.
Fault Tolerance: Kafka provides fault tolerance through data replication and persistence. EventBus usually does not provide the same level of fault tolerance.
Complexity: Kafka is more complex to set up and manage, requiring a cluster of brokers and ZooKeeper for coordination. EventBus is simpler and easier to integrate into applications.
Persistence: Kafka persists messages to disk, ensuring durability and reliability. EventBus typically handles events in memory, which may not be durable.
Example Use Cases
Kafka: Use Kafka for building a real-time analytics platform that processes and analyzes log data from multiple sources.
EventBus: Use EventBus for communication between microservices in a web application, where events are lightweight and do not require persistence.
By understanding the differences between Kafka and EventBus, you can choose the appropriate tool based on your specific requirements and use cases.

-----------------------------------------------OpenApi/Swagger/SwashBuckle---------------------------------------------

Ref: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-8.0

Swashbuckle is a library that generates beautiful API documentation
Swagger UI, to explore and test API operations
Swagger tools for APi: =>   Its overall functioning depends upon the three primary components, AspNetCore.SwaggerGen, AspNetCore.SwaggerUI and AspNetCore.Swagger. All three work in collaboration to provide JSON and XML-based files containing responses. https://positiwise.com/blog/essential-net-core-libraries-that-every-programmer-should-know
  Swashbuckle.AspNetCore
  Swashbuckle.AspNetCore.SwaggerUI
  Swashbuckle.AspNetCore.Swagger
  Swashbuckle.AspNetCore.SwaggerGen


What is the OpenAPI Specification?
The OpenAPI Specification (OAS) defines a standard, programming language-agnostic interface description for HTTP APIs, which
allows both humans and computers to discover and understand the capabilities of a service without requiring access to source
code, additional documentation, or inspection of network traffic. When properly defined via OpenAPI, a consumer can understand
and interact with the remote service with a minimal amount of implementation logic. Similar to what interface descriptions
have done for lower-level programming, the OpenAPI Specification removes guesswork in calling a service.


***The OpenAPI specification is a programming [language-agnostic] standard for [documenting HTTP APIs]***

There are three key aspects to OpenAPI integration in an application:
1) Generating information about the endpoints in the app.
2) Gathering the information into a format that matches the OpenAPI schema.
3) Exposing the generated OpenAPI schema via a visual UI or a serialized file.


**Minimal APIs** provide built-in support for generating information about endpoints in an app
                 via the ****Microsoft.AspNetCore.OpenApi package***

Exposing the generated OpenAPI definition via a visual UI requires a third-party package.


Request body parameters that are read from a form via the [FromForm] attribute are described with the
multipart/form-data content-type.

All other request body parameters are described with the application/json content-type.

The two main OpenAPI implementations for .NET are Swashbuckle and NSwag

OpenAPI is a specification.
Swagger is tooling that uses the OpenAPI specification. For example, OpenAPIGenerator and SwaggerUI.


Get started with Swashbuckle and ASP.NET Core
https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-8.0&tabs=visual-studio

Add following to .csproj file to generate comments in swaggerUI based on code change
<PropertyGroup>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
</PropertyGroup>


ValidateModelState validates the parameters of the action method. Parameter can be a model with attributes
such as [Required]. Apply to all types (get, post etc) of methods with parameters



Decorate like the following to show responses if need to

        /// <summary>
        /// </summary>
        /// <remarks></remarks>
        /// <response code="200">success.</response> <------------------------------------------------------
        /// <response code="204">No Data Found</response>
        /// <response code="400">Bad Request. The request does not meet validation rules.</response>
        /// <response code="403">User does not have access to the Source System.</response>
        /// <response code="500">Unexpected Internal Server Error</response>
        [HttpPost]
        [ValidateModelState]
        [Route("/someUrl")]
        [Produces(contentType: "application/json")]
        [ProducesResponseType(typeof(Domain.Models.SomeResponseModel), 200)] <-------------------
        [ProducesResponseType(typeof(Domain.Models.ProblemDetails), 204)]
        [ProducesResponseType(typeof(Domain.Models.ProblemDetails), 400)]
        [ProducesResponseType(typeof(Domain.Models.ProblemDetails), 403)]
        [ProducesResponseType(typeof(Domain.Models.ProblemDetails), 500)]
        public async Task<IActionResult> SomePost([FromBody] SomeClass obj)
        {


To download Swagger file, copy the json url (http://localhost:5223/swagger/version1/swagger.json) and open in browser.
then right click save as json file.

You can convert json to yaml if needed.


------------------------------------------.Net Core Api - Controller Based Apis-----------------------------------------------------
Tutorial: https://learn.microsoft.com/en-us/training/modules/build-web-api-aspnet-core/

Misc: WebApi with .Net core Video Series
https://www.youtube.com/playlist?list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v

Ref: https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-8.0

Controller Base class:
  ControllerBase => for WebApis
  Controller (derives from ControllerBase) => for Webpages (adds support for Views)


The ControllerBase class provides many properties and methods that are useful for handling HTTP requests.
ControllerBase has a bunch of helper methods eg:
CreatedAtAction         e.g return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet);
BadRequest	        Returns 400 status code.
NotFound	        Returns 404 status code.
PhysicalFile	        Returns a file.
TryUpdateModelAsync	Invokes model binding.
TryValidateModel	Invokes model validation.

Here are some more examples of attributes that are available.
Attribute	Notes
[Route]	Specifies URL pattern for a controller or action.
[Bind]	Specifies prefix and properties to include for model binding.         <---------------
[HttpGet]	Identifies an action that supports the HTTP GET action verb.
[Consumes]	Specifies data types that an action accepts.                  <---------------
[Produces]	Specifies data types that an action returns.                  <---------------

*****ApiController attribute*****

The [ApiController] attribute can be applied to a controller class to enable the following opinionated, API-specific behaviors:

1) Attribute routing requirement
2) Automatic HTTP 400 responses
3) Binding source parameter inference     <-- source of parameter
4) Multipart/form-data request inference
5) Problem details for error status codes  <----------------

Apply [ApiController] attribute to all controller since it enables Problem details for error status codes (have exception middleware)

The [ApiController] attribute makes ***attribute routing*** a requirement. Eg  <--- Have to use Attribute Routing
[Route("[controller]")]
public class SomeController : ControllerBase


Automatic HTTP 400 responses
The [ApiController] attribute makes model validation errors automatically trigger an HTTP 400 response. Consequently, the following code
is unnecessary in an action method:
if (!ModelState.IsValid)
{
    return BadRequest(ModelState);
}

The default response type for an HTTP 400 response is ValidationProblemDetails (indirectly inherits from ProblemDetails)
Inheritance: Object => ProblemDetails => HttpValidationProblemDetails => ValidationProblemDetails


Binding source parameter inference
Attribute	Binding source
[FromBody]	Request body
[FromForm]	Form data in the request body
[FromHeader]	Request header
[FromQuery]	Request query string parameter  => value is provided in the request URL's query string
[FromRoute]	Route data from the current request
[FromServices]	The request service injected as an action parameter
[AsParameters]	Method parameters   <--- combine parameters to an object


Warning

Don't use [FromRoute] when values might contain %2f (that is /). %2f won't be unescaped to /.
Use [FromQuery] if the value might contain %2f.

The [ApiController] attribute applies inference rules for the default data sources of action parameters.
Best is to explicity specify it to avoid ambiguity <----------------------------

[FromServices] is inferred for complex type parameters registered in the DI Container.
[FromBody] is inferred for complex type parameters not registered in the DI Container. An exception to the [FromBody] inference rule is any complex, built-in type with a special meaning, such as IFormCollection and CancellationToken. The binding source inference code ignores those special types.
[FromForm] is inferred for action parameters of type IFormFile and IFormFileCollection. It's not inferred for any simple or user-defined types.
[FromRoute] is inferred for any action parameter name matching a parameter in the route template. When more than one route matches an action parameter, any route value is considered [FromRoute].
[FromQuery] is inferred for any other action parameters.

[FromBody] isn't inferred for simple types such as string or int. Therefore, the [FromBody] attribute should be used for simple types when that functionality is needed.

ASP.NET Core only allows one parameter to be bound from the body of the request.
If you have 2 objects, then use  a DTO and combine parameters
public class ProductOrderDto
{
    public Product Product { get; set; }
    public Order Order { get; set; }
}


Following will throw an exception since only 1 parameter can be bound from Body. Inferred to use [FromBody] for both parameters which is not correct
[HttpPost]
public IActionResult Action1(Product product, Order order)

Parameter binding binds parameters through dependency injection when the type is configured as a service.

https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-8.0#fromservices-inference-notes
Automatic DI can break apps that have a type in DI that is also accepted in an API controller's action methods

Binding for Action method's parameters uses the following rules:
A previously specified BindingInfo.BindingSource is never overwritten.
A complex type parameter, registered in the DI container, is assigned BindingSource.Services.
A complex type parameter, not registered in the DI container, is assigned BindingSource.Body.
A parameter with a name that appears as a route value in any route template is assigned BindingSource.Path.
All other parameters are BindingSource.Query.

-----------ProblemDetails
https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-8.0#problem-details-for-error-status-codes
MVC transforms an error result (a result with status code 400 or higher) to a result with ProblemDetails. <----------------------ProblemDetails

The ProblemDetails type is based on the RFC 7807 specification for providing machine-readable error details in an HTTP response.


-------------------Error Handling Plus Unhandled Exceptions

if (pet == null)
{
    return NotFound();  // status code 404
}

Ref: https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-8.0#problem-details-for-error-status-codes

// MVC transforms an error result (a result with status code 400 or higher) to a result with ProblemDetails.
// will automatically be converted to a ProblemDetails response if status code  status code 400 or higher
// eg   Below is ProblemDetails json object
//{
//  type: "https://tools.ietf.org/html/rfc7231#section-6.5.4",
//  title: "Not Found",
//  status: 404,
//  traceId: "0HLHLV31KRN83:00000001"
//}

return NotFound() will return above ProblemDetails json object by default in .Net Core <-----evaluate if can use for existing pages. object ok? else only use for new development

Moral: Existing UI needs specific Api return objects. For existing methods, just return same. For new development/methods, return modern
way. Make it work for existing UI but keep it open so that new development can use modern way. Cannot again update Angular 15 UI.



ExceptionToProblemDetailsHandler is executed for Unhandled Exceptions

throw new Exception("Dan's Test Exception");

It also returns ProblemDetails object in response body with status code 500

{
  "type": "https://tools.ietf.org/html/rfc9110#section-15.6.1",
  "title": "Internal Server Error",
  "status": 500,
  "detail": "Dan's Test Exception",
  "instance": "GET /devint/api/project-api/pettest"
}



Format ProblemDetails and ValidationProblemDetails responses
https://learn.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting?view=aspnetcore-8.0#format-problemdetails-and-validationproblemdetails-responses

[HttpGet("Error")]
public IActionResult GetError()
    => Problem("Something went wrong.");

When the [ApiController] attribute is applied to a controller class, the controller creates a ValidationProblemDetails response when Model Validation fails.

Handle Errors: https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-8.0

The Developer Exception Page displays detailed information about ***unhandled request exceptions***

Custom Exception Handler using Exception Base class and ActionFilter
https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-8.0#use-exceptions-to-modify-the-response

ValidationProblemDetails: when model validation fails, MVC responds with a ValidationProblemDetails response type
ProblemDetails: when reponse HTTP status code is 400 or higher, MVC transforms an error result to produce a ProblemDetails response type

The default problem details response body has the following type, title, and status values:
{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "Bad Request",
  "status": 400,
  "traceId": "00-84c1fd4063c38d9f3900d06e56542d48-85d1d4-00"
}

builder.Services.AddProblemDetails();
The following code configures the app to generate a problem details response for all HTTP client and server error responses
that don't have body content yet:

When ProblemDetails is returned
A problem details response is generated with the preceding code when any of the following conditions apply:
An invalid input is supplied.
The URI has no matching endpoint.
An unhandled exception occurs.


return NotFound();  Or return BadRequest(); => will return ProblemDetails


ProblemDetails <-- provides a uniformed way to report back errors to the client in .net core
1:11
https://www.youtube.com/watch?v=xx3wbDlYbUY&list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v&index=13


--------------------Documenting API withs Swagger 5 min-----------------------------
https://www.youtube.com/watch?v=IBw3ONR1d7E&list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v&index=16
















-------------------Error Handling Plus Unhandled Exceptions End


-------------------Controller Action return types in ASP.NET Core web API

[HttpPost]
[Consumes("application/xml")]
public IActionResult CreateProduct(Product product)

Requests routed to this action must specify a Content-Type header of application/xml.


Controller action return types in ASP.NET Core web API: https://learn.microsoft.com/en-us/aspnet/core/web-api/action-return-types?view=aspnetcore-8.0

web API controller action return types
Specific type       Task<List<Product>>
IActionResult       IActionResult (synchronous version) Or async Task<IActionResult> (asynchronous version)
ActionResult<T>     ActionResult<Product>  Or async Task<ActionResult<Product>>  <-------------- Prefer since is type safe. But can provide same result as IActionResult
HttpResults
IResult             IResult Or Task<IResult>


Specific type.
The IActionResult return type is appropriate when multiple ActionResult return types are possible in an action.



C# yield keyword. returns IEnumerable<T>
Below both will return the same result IEnumerable<Product>. However, yield

•	Memory Efficiency: Using yield is more memory-efficient because it generates items on-the-fly and doesn't require storing the entire collection in memory.
•	Lazy Evaluation: yield allows for lazy evaluation, meaning items are only generated when they are requested.
•	Code Simplicity: Using yield can make the code more concise and easier to read.

        [HttpGet("syncsale")]
        public IEnumerable<Product> GetOnSaleProducts()
        {
            var products = _productContext.Products.OrderBy(p => p.Name).ToList();

            foreach (var product in products)
            {
                if (product.IsOnSale)
                {
                    yield return product;
                }
            }
        }

[HttpGet("syncsale")]
public IEnumerable<Product> GetOnSaleProducts()
{
    var products = _productContext.Products.OrderBy(p => p.Name).ToList();
    var onSaleProducts = new List<Product>();

    foreach (var product in products)
    {
        if (product.IsOnSale)
        {
            onSaleProducts.Add(product);
        }
    }

    return onSaleProducts;
}

var test = Integers();
Debug.WriteLine(test);
var f = 22;
IEnumerable<int> Integers()
{
    yield return 1;
    yield return 2;
    yield return 4;
    yield return 8;
    yield return 16;
    yield return 16777216;
}
-------------------Controller Action return types in ASP.NET Core web API End


-------------------JsonPatch in ASP.NET Core web API

Serialization and Deserialization using System.Text.Json <----
using System.Text.Json;
string jsonString = JsonSerializer.Serialize(person);

string jsonString = "{\"FirstName\":\"John\",\"LastName\":\"Doe\",\"Age\":30}";
Person person = JsonSerializer.Deserialize<Person>(jsonString);


Serialization and Deserialization using Newtonsoft.Json <------
using Newtonsoft.Json;
string jsonString = JsonConvert.SerializeObject(person);

string jsonString = "{\"FirstName\":\"John\",\"LastName\":\"Doe\",\"Age\":30}";
Person person = JsonConvert.DeserializeObject<Person>(jsonString);


• System.Text.Json: Built-in, faster, and more memory-efficient but with fewer features.
• Newtonsoft.Json: Richer feature set, more flexible, and widely used but generally slower and more memory-intensive.

In .net core, System.Text.Json is the default serializer.
 Can use both as needed System.Text.Json and Newtonsoft.Json



JSON Patch is particularly useful in RESTful APIs where you want to update only specific fields of a resource without
sending the entire resource representation.
https://learn.microsoft.com/en-us/aspnet/core/web-api/jsonpatch?view=aspnetcore-8.0

----------Format response data in ASP.NET Core Web API
https://learn.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting?view=aspnetcore-8.0

For actions with multiple return types, return IActionResult.

By default, ASP.NET Core supports the following media types:
application/json
text/json
text/plain


By default, when the framework detects that the request is coming from a browser:

The Accept header is ignored. <---------------
The content is returned in JSON, unless otherwise configured.

To configure an app to respect browser accept headers, set the RespectBrowserAcceptHeader property to true:

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers(options =>
{
    options.RespectBrowserAcceptHeader = true;
});

Apps that need to support extra formats can add the appropriate NuGet packages and configure support.
There are separate formatters for input and output.

Input formatters are used by Model Binding.
Output formatters are used to format responses.

You can specify custom formatters for specific actions
https://learn.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting?view=aspnetcore-8.0#configure-systemtextjson-based-formatters-2
[HttpGet]
public IActionResult Get()
    => new JsonResult(
        _todoItemStore.GetList(),
        new JsonSerializerOptions { PropertyNamingPolicy = null });

.Net Core Equivalent using System.Text.Json. don't need to include null values. by default, it will

    //Add Snake case JSON output
    builder.Services.Configure<JsonOptions>(option =>
    {
        options.JsonSerializerOptions.ReferenceHandler = System.Text.Json.Serialization.ReferenceHandler.IgnoreCycles;
        option.JsonSerializerOptions.PropertyNamingPolicy = SnakeCaseNamingPolicy.Instance;
    });

ASP.NET Core MVC supports data exchange in Web APIs using input and output formatters.
Input formatters are used by Model Binding.
Output formatters are used to format responses.


***Use web API conventions***

Default API conventions: https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.defaultapiconventions?view=aspnetcore-8.0


ModelBinding & ModelValidation
https://code-maze.com/aspnetcore-modelstate-validation-web-api/

model binding:    The model binding arises errors that can occur when attempting to bind values from an HTTP
                  request to an action method, generally data conversion errors
model validation:  After the model binding comes model validation, the moment when we check the business rules of our domain.

[Required], [MaxLength(250)] and [StringLength(13, MinimumLength = 13)] are validation attributes from the
System.ComponentModel.DataAnnotations namespace

If we can’t find any appropriate built-in attributes we can write ***custom validation attributes*** as well.


C#: nullable reference types
In C# 8.0, the concept of nullable reference types (NRTs) was introduced. This feature allows you to explicitly indicate
whether a reference type can be null or not. When nullable reference types are enabled, the compiler provides warnings
if you try to assign null to a non-nullable reference type or if you fail to check for null before dereferencing a
 nullable reference type.

By default, ASP.NET Core treats non-nullable reference types as if they have an implicit [Required] attribute. This means
that during model binding and validation, non-nullable reference types are automatically considered required, and a
validation error will be generated if a value is not provided for them.


When we talk about ModelState, we mean ModelState property of the ControllerBase abstract class in the
Microsoft.AspNetCore.Mvc namespace.





.Net Api Tutorial <--- TODO
https://learn.microsoft.com/en-us/training/modules/build-web-api-aspnet-core/

---------------.Net Core Api: Tutorial


Tutorial: https://learn.microsoft.com/en-us/training/modules/build-web-api-aspnet-core/  <---Crappy. not good

Simple serialization: ASP.NET was designed for modern web experiences. Endpoints automatically serialize your classes to
properly formatted JSON out of the box. No special configuration is required. You can customize serialization for endpoints
that have unique requirements.


------------------------------------------.Net Core---------------------------------

<==================================Here 1 of 3


Microsoft .Net Core - General: https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-8.0 <-----------
(see whole tree)
eg Endpoint Filters: https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0

Fundamenatals****: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/?view=aspnetcore-8.0&tabs=windows
  Dependency Injection
  Configuration Settings in .Net Core: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-8.0
  Handle Errors


https://www.youtube.com/watch?v=qBTe6uHJS_Y
https://www.youtube.com/@TeddySmithDev/videos (32 videos)
https://www.youtube.com/watch?v=E6sUJWwZLwE

https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-8.0&WT.mc_id=dotnet-35129-website
https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-8.0&tabs=visual-studio
https://learn.microsoft.com/en-us/shows/dotnetconf-2023/minimal-api-spa-a-perfect-match

Youtube:
https://www.youtube.com/watch?v=DFDbh1c9zyE
https://www.youtube.com/watch?v=E6sUJWwZLwE
https://www.youtube.com/watch?v=qBTe6uHJS_Y
https://www.youtube.com/@TeddySmithDev/videos  (32 videos)


Reference:
https://www.yogihosting.com/category/aspnet-core/

Restful Api: https://medium.com/@chandrashekharsingh25/build-a-restful-web-api-with-net-8-44fc93b36618



-------Microsoft .Net Core - General: https://learn.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-8.0-------

Important topics
 Fundamentals
 Web apps > Advanced
 Advanced
 Data Access
 Security and Identity
 Best practices
 Tutorials

Skim
 Host & Deploy
 Remote Procedure Call apps (Grpc)

??
 Tutorials > Data Access (Only applicable to Razor pages  and MVC? Concepts still apply for APIs?)
 Performance

////////////////////////////////////////////

https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0
HTTP API apps
Vs
Page-focused web UI with Razor Pages
Page-focused web UI with MVC


.Net Vs .Net Framework
https://learn.microsoft.com/en-us/dotnet/standard/choosing-core-framework-server?toc=%2Faspnet%2Fcore%2Ftoc.json&bc=%2Faspnet%2Fcore%2Fbreadcrumb%2Ftoc.json&view=aspnetcore-8.0
WCF is only available in .Net Framework
Some third-party libraries or NuGet packages are only available for .Net Framework and not for .Net

The Program.cs file is where:
Services required by the app are configured.
The app's request handling pipeline is defined as a series of middleware components.


------------------------------------Middleware - Part 1 of 2
Middleware Order
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#middleware-order

Middleware is software that's assembled into an app pipeline to handle requests and responses.

Each component:
Chooses whether to pass the request to the next component in the pipeline.
Can perform work before and after the next component in the pipeline.

https://learn.microsoft.com/en-us/aspnet/core/fundamentals/?view=aspnetcore-8.0&tabs=windows#middleware

The request handling pipeline is composed as a series of middleware components
ach component performs operations on an HttpContext and either invokes the next middleware in the pipeline or terminates
the request.

By convention, a middleware component is added to the pipeline by invoking a Use{Feature} extension method.

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");  <--- Adding Middleware
    app.UseHsts();          <--- Adding Middleware
}

app.UseHttpsRedirection();  <--- Adding Middleware
app.UseStaticFiles();       <--- Adding Middleware

app.UseAuthorization();     <--- Adding Middleware


On startup, an ASP.NET Core app builds a host. The host encapsulates all of the app's resources, such as:

An HTTP server implementation
Middleware components
Logging
Dependency injection (DI) services
Configuration

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

The WebApplicationBuilder.Build method configures a host with a set of default options, such as:
Use Kestrel as the web server and enable IIS integration.
Load configuration from appsettings.json, environment variables, command line arguments, and other configuration sources.
Send logging output to the console and debug providers.

ASP.NET Core provides the following server implementations:
Kestrel is a cross-platform web server.
IIS HTTP Server
HTTP.sys is a server for Windows that isn't used with IIS.

Configuration
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/?view=aspnetcore-8.0&tabs=windows#configuration

By default, ASP.NET Core apps are configured to read from appsettings.json, environment variables, the command line,
and more


When the app's configuration is loaded, values from environment variables override values from appsettings.json <--------

For confidential data : For managing confidential configuration data such as passwords, .NET Core provides the Secret Manager. For production secrets, we recommend Azure Key Vault.
In Dev: Use Secrets
In Prod: Use Azure Key Vault Or Aws equivalent

<ItemGroup>
	<Content Update="appsettings.json">
		<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
		<ExcludeFromSingleFile>true</ExcludeFromSingleFile>
		<CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
	</Content>
</ItemGroup>
This section specifies how certain content files should be handled. For example, appsettings.json is set to be copied to the output and publish directories if it is newer than the existing file.


IStartupFilter (eg set an options value from a query string parameter)
To execute middleware in the beginning or end of an app's middleware pipeline without an explicit call to Use{Middleware}.
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-8.0


-----------------------Dependency injection in ASP.NET Core (https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-8.0)

The use of an ***interface*** OR ***base class*** to abstract the dependency implementation

Logging
The following code demonstrates using the default logging, which ***doesn't require*** any services to be registered:
Using the below code, there is no need to update Program.cs, because logging is provided by the framework.

public class AboutModel : PageModel
{
    private readonly ILogger _logger;

    public AboutModel(ILogger<AboutModel> logger) => ILogger of the class name
    {
        _logger = logger;
    }

    public string Message { get; set; } = string.Empty;

    public void OnGet()
    {
        Message = $"About page visited at {DateTime.UtcNow.ToLongTimeString()}";
        _logger.LogInformation(Message);
    }
}

Manually creating a Scope (https://andrewlock.net/the-dangers-and-gotchas-of-using-scoped-services-when-configuring-options-in-asp-net-core/)
In addition to the automatic scopes created for each request, it's possible to create a new scope manually, using
IServiceProvider.CreateScope(). You can use this to safely resolve Scoped services outside the context of a request
for example after you've configured your application, but before you call IWebHost.Run(). This can be useful when you
need to do things like run EF Core migrations, for example.


Disposal of services
The container calls Dispose for the IDisposable types it creates. Services resolved from the container should never be
disposed by the developer. However class will need to inherit from IDisposable
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-8.0#disposal-of-services
eg container created service: builder.Services.AddSingleton<Service2>();

Services not created by the service container eg
builder.Services.AddSingleton(new Service2())


In the preceding code:

The service instances aren't created by the service container.
The framework doesn't dispose of the services automatically.
The developer is responsible for disposing the services.


Dependency Injection Guidelines: https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines#recommendations

Avoid using the service locator pattern. For example, don't invoke GetService to obtain a service instance when you
can use DI instead.
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-8.0#recommendations

If can do DI, then don't do this. DI preferred over GetService
services.AddScoped<IServiceProvider, ServiceProvider>();
_serviceProvider.GetService<DotnetTemplateRendererService>()


Framework-provided services
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-8.0#framework-provided-services

-----------------------Dependency injection in ASP.NET Core  End


-----------------------ASP.NET Core Middleware - Part 2 of 2
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0

Middleware Order
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#middleware-order

Middleware is software that's assembled into an app pipeline to handle requests and responses.

Each component:
Chooses whether to pass the request to the next component in the pipeline.
Can perform work before and after the next component in the pipeline.

Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.

Request delegates are configured using ***Run, Map, and Use*** extension methods.

An individual request delegate can be specified in-line as an anonymous method (called in-line middleware), or it can
be defined in a reusable class

Each delegate can perform operations before and after the next delegate.

Exception-handling delegates should be called early in the pipeline, so they can catch exceptions that occur in later
stages of the pipeline.

The next parameter represents the next delegate in the pipeline. You can short-circuit the pipeline by not calling the next parameter.

Chain multiple request delegates together with Use.
app.Use(async
app.Run();

Run delegates don't receive a next parameter. The first Run delegate is always terminal and terminates the pipeline. Run is a convention.

app.Run(async context =>
{
    await context.Response.WriteAsync("Hello from 2nd delegate.");
});

app.Run();


• Registers what class to use for exception handling. This is a service registration step. It configures the service collection to use a specific implementation for handling exceptions.
builder.Services.AddExceptionHandler<SomeClassHandler>();

•Adds ExceptionHandling middleware. This is a middleware configuration step. It ensures that the exception handling middleware is part of the request processing pipeline.
app.UseExceptionHandler();


UseExceptionHandler is the first middleware component added to the pipeline. Therefore, the Exception Handler Middleware catches any exceptions that occur in later calls.

Forwarded Headers Middleware should run before other middleware. This ordering ensures that the middleware relying on
forwarded headers information can consume the header values for processing.


app.Map() <= specify url routes
app.Use() <= Add middleware to request pipeline
app.Run()  <= Adds a terminal middleware to the request pipeline. Middleware added with app.Run() does not call the next middleware. It is intended to be the final piece of middleware that handles the request and generates the response.

Middleware is constructed at app startup and therefore has application life time


--------------------------Host-------------------------
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/webapplication?view=aspnetcore-8.0

Can set Ports from Environments
var port = Environment.GetEnvironmentVariable("PORT") ?? "3000";

OR preferred way to set the port from the environment is to use the ASPNETCORE_URLS environment variable
ASPNETCORE_URLS=http://localhost:3000

Development certificates: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/webapplication?view=aspnetcore-8.0#read-the-port-from-environment


1) Specify the custom certificate with appsettings.json => https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/webapplication?view=aspnetcore-8.0#specify-the-custom-certificate-with-appsettingsjson
 "Kestrel": {
    "Certificates": {
      "Default": {
        "Path": "cert.pem",
        "KeyPath": "key.pem"
      }
    }


2) Specify the custom certificate via configuration => https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/webapplication?view=aspnetcore-8.0#specify-the-custom-certificate-via-configuration
var builder = WebApplication.CreateBuilder(args);

// Configure the cert and the key
builder.Configuration["Kestrel:Certificates:Default:Path"] = "cert.pem";
builder.Configuration["Kestrel:Certificates:Default:KeyPath"] = "key.pem";

how to get services from the DI container during application startup: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/webapplication?view=aspnetcore-8.0#access-the-dependency-injection-di-container

-------------------------------Configuration---------------------------------------------

https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-8.0


Application configuration in ASP.NET Core is performed using one or more configuration providers.
Configuration providers read configuration data from key-value pairs using a variety of configuration sources:

Settings files, such as appsettings.json
Environment variables (Octopus? or computer?)  --- Secrets use local computer that is not checked into source control
Azure Key Vault Or Equivalent AWS service     (Prod)


Azure App Configuration
Command-line arguments
Custom providers, installed or created
Directory files
In-memory .NET objects


Bind the Position section from appSettings using PositionOptions class and add it to the dependency injection service container.
builder.Services.Configure<PositionOptions>(
    builder.Configuration.GetSection(PositionOptions.Position));

To read it either use Dependency Injection or use Getservice

1)
public class Test2Model : PageModel
{
    private readonly PositionOptions _options;

    public Test2Model(IOptions<PositionOptions> options)
    {
        _options = options.Value;
    }

 public ContentResult OnGet()
    {
        return Content($"Title: {_options.Title} \n" +
                       $"Name: {_options.Name}");
    }
}


2)  var apiSettingOptions = app.Services.GetRequiredService<IOptions<PositionOptions>>();
    app.UsePathBase(apiSettingOptions.Value.Title);

Secret keys override appsettings.json and appsettings.{Environment}.json.
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-8.0#security-and-user-secrets

Environment variables & Secrets
https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-8.0&tabs=windows

Add this for connection from .Net Api to SqlServer to use SSL
TrustServerCertificate=true;Encrypt=true;

connectionstring syntax:
https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax

connectionstring valid values
https://learn.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection.connectionstring?view=netframework-4.8.1

Environment variables override configuration values for all previously specified configuration sources.

Configuration Source Order: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-8.0#default-application-configuration-sources
1)Command-line arguments using the Command-line configuration provider.

2)Non-prefixed environment variables using the Non-prefixed environment variables configuration provider.
3)User secrets when the app runs in the Development environment.
4)appsettings.{Environment}.json using the JSON configuration provider. For example, appsettings.Production.json and appsettings.Development.json.
5)appsettings.json using the JSON configuration provider.

6) A fallback to the host configuration described in the next section.


environment variable     override    user secrets    override    appsettings.{Environment}.json   override   appsettings.json


Environment.GetEnvironmentVariable("LOGSTASH_URL")
The value for Environment.GetEnvironmentVariable("LOGSTASH_URL") will be read from the environment variables of the
operating system where the application is running.
Environment Variables of the Server where API is running (Edit environment variables)
Dev Server
Qa Server


Environment.GetEnvironmentVariable("NEXTHINK2") => computer's/server environment variable (edit environment varibales) where
API is running. Dev, QA, Prod => seperate Environment specific

In an ASP.NET Core application, the IConfiguration object aggregates configuration values from various sources
appsettings.json, appSettings.development.json, user secrets, Environment Variables
var configuration = builder.Configuration; =>
var test2 = configuration["NEXTHINK2"]; => appsettings.json => appSettings.development.json => user secrets => Environment Variables (highest precedence)

builder.Configuration sources

Highest Precedence:
Custom configuration providers you might add eg Azure Key Vault or AWS equivalent (Prod)
  In-Memory Configuration => Configuration values added programmatically during runtime.
  Command-Line Arguments => Arguments passed to the application via the command line.
Environment Variables (Per computer/server environment)   [Vs Octopus tokenized values via appSettings ?????] => Which way?? Environment specific values
user secrets (Dev)
appSettings.development.json
appsettings.json


Secrets only used for Dev. Prod use AWS

Octopus tokenized values?


Which one follow for API??

Individual Server's Environment variables (Dev, QA etc) override appsettings.json (same variable name)  <= docs say this
Vs
appsettings.json contained tokenized values that get replaced via Octopus build


---------Naming of environment variables
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-8.0#naming-of-environment-variables

Environment variable names reflect the structure of an appsettings.json file

Each element in the hierarchy is separated by a double underscore (preferable) or a colon.

Environment variables set in launchSettings.json override those set in the system environment.


In environment variables, a colon separator may not work on all platforms. A double underscore, __, is supported by all platforms and is automatically converted into a colon :

Configuration values:

Are strings.
Null values can't be stored in configuration or bound to objects.

Configuration providers available to ASP.NET Core

Provider				Provides configuration from
Azure Key Vault configuration provider	Azure Key Vault
Azure App configuration provider	Azure App Configuration
Command-line configuration provider	Command-line parameters
Custom configuration provider		Custom source
Environment Variables configuration provider	Environment variables
File configuration provider		INI, JSON, and XML files
Key-per-file configuration provider	Directory files
Memory configuration provider		In-memory collections
User secrets				File in the user profile directory


Configuration sources are read in the order that their configuration providers are specified. Order configuration providers in code to suit the priorities for the underlying configuration sources that the app requires.


Configuration providers Order (Last one overrides previous ones)

appsettings.json
appsettings.{Environment}.json
User secrets
Environment variables using the Environment Variables configuration provider.
Command-line arguments using the Command-line configuration provider.


ConfigurationBinder.GetValue extracts a single value from configuration with a specified key and converts it to the specified type:
var number = Configuration.GetValue<int>("NumberKey", 99);

Config = configuration.GetSection("section1");
Config = configuration.GetSection("section2:subsection0");

GetSection never returns null. If a matching section isn't found, an empty IConfigurationSection is returned.

Options configured in a delegate override values set in the configuration providers


launch.json/launchSettings.json are tooling configuration files for the Development environment

web.config is a server configuration file


https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-8.0#other-configuration

Environment variables set in launchSettings.json override those set in the system environment.
Eg ASPNETCORE_ENVIRONMENT set in launchSettings.json with value of Development will override value in ASPNETCORE_ENVIRONMENT storedin Environment Variables on the local computer/server. Therefore on local
laptop ASPNETCORE_ENVIRONMENT value will be Development where as on QA server the ASPNETCORE_ENVIRONMENT value
will be QA or whatever the ASPNETCORE_ENVIRONMENT Environment Variable value is on the QA server

-----------------------------Options Pattern
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-8.0

The preferred way to read related configuration values is using the options pattern.

IOptions<TOptions>:

Does not support:
Reading of configuration data after the app has started.
Named options
Is registered as a Singleton and can be injected into any service lifetime.


services.AddOptions()

•Options Pattern: The options pattern is a way to represent groups of related settings in a strongly-typed way. It allows you to bind configuration settings to classes and inject these classes into your services.
•Configuration Binding: By calling services.AddOptions(), you enable the ability to bind configuration sections to POCO (Plain Old CLR Object) classes using the IOptions<T> interface.


Services can be accessed from dependency injection while configuring options in two ways:

Not used in project** but is preferred
1) Pass a configuration delegate to Configure on OptionsBuilder<TOptions>. OptionsBuilder<TOptions> provides overloads of Configure that allow use of up to five services to configure options
builder.Services.AddOptions<MyOptions>("optionalName")
    .Configure<Service1, Service2, Service3, Service4, Service5>(
        (o, s, s2, s3, s4, s5) =>
            o.Property = DoSomethingWith(s, s2, s3, s4, s5));

Used****
2) Create a type that implements IConfigureOptions<TOptions> or IConfigureNamedOptions<TOptions> and register the type as a service.


----------------------------Environments
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/environments?view=aspnetcore-8.0

The launchSettings.json file sets ASPNETCORE_ENVIRONMENT to Development on the local machine.

For Qa, Prod can set Environment Variable 'ASPNETCORE_ENVIRONMENT' on server?


Environment values set in launchSettings.json override values set in the system environment variables


The launchSettings.json file:

Is only used on the local development machine.
Is not deployed.
Contains profile settings.

in launchSettings.json, commandName can be any one of the following:

IISExpress : Launches IIS Express.
IIS : No web server launched. IIS is expected to be available.
Project : Launches Kestrel.

Warning
launchSettings.json shouldn't store secrets. The Secret Manager tool can be used to store secrets for
local development.


both launchSettings.json and .vscode/launch.json are checked into source control

**********Visual Studio uses launchSettings.json**********
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:53218",
      "sslPort": 0
    }
  },

}


**********Visual Studio Code uses .vscode/launch.json**********
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": ".NET Core Launch (web)",
            "type": "coreclr",
            // Configuration ommitted for brevity.
            "env": {
                "ASPNETCORE_ENVIRONMENT": "Development",    <------------
                "ASPNETCORE_URLS": "https://localhost:5001",
                "ASPNETCORE_DETAILEDERRORS": "1",
                "ASPNETCORE_SHUTDOWNTIMEOUTSECONDS": "3"
            },
            // Configuration ommitted for brevity.


https://learn.microsoft.com/en-us/aspnet/core/fundamentals/environments?view=aspnetcore-8.0#production
Production
 Caching.
 Client-side resources are bundled, minified, and potentially served from a CDN.
 Diagnostic error pages disabled.
 Friendly error pages enabled.
 Production logging and monitoring enabled. For example, using Application Insights.

It's often useful to set a specific environment for testing with an environment variable or platform setting.
If the environment isn't set, it defaults to Production <------------------------------

When the host is built, the last environment setting read by the app determines the app's environment.

Production is the default value if DOTNET_ENVIRONMENT and ASPNETCORE_ENVIRONMENT have not been set.

-------------------ASPNETCORE_ENVIRONMENT Setting-------------------------------

launchSettings.json (Visual Studio) Or .vscode/launch.json (VsCode)
  Development in launchSettings.json & .vscode/launch.json

Environment variables on the computer
 https://learn.microsoft.com/en-us/aspnet/core/fundamentals/environments?view=aspnetcore-8.0#windows---set-environment-variable-globally
 ASPNETCORE_ENVIRONMENT value can be set on Environment variables on the computer. See snapshot

web.config (sample projects don't use it)
  To set the ASPNETCORE_ENVIRONMENT environment variable with web.config, see the Set environment variables section of
  web.config file.

  <aspNetCore processPath="dotnet"
      arguments=".\MyApp.dll"
      stdoutLogEnabled="false"
      stdoutLogFile=".\logs\stdout"
      hostingModel="inprocess">
   <environmentVariables>
    <environmentVariable name="ASPNETCORE_ENVIRONMENT" value="Development" />
    <environmentVariable name="CONFIG_DIR" value="f:\application_config" />
   </environmentVariables>
  </aspNetCore>

Restart server after changing the value: ASPNETCORE_ENVIRONMENT
When hosting an app in IIS and adding or changing the ASPNETCORE_ENVIRONMENT environment variable, use one of the following approaches to have the new value picked up by apps:

Execute net stop was /y followed by net start w3svc from a command prompt.
Restart the server.


------------------------Logging and monitoring
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-8.0


To create logs, use an ILogger<TCategoryName> object from dependency injection (DI).
log category of the fully qualified name of the type AboutModel.

    public AboutModel(ILogger<AboutModel> logger)
    {
        _logger = logger;
    }


ILogger<EmailService> log

EmailService is the category. The ILogger<EmailService> specifies the type EmailService as the category for the logger

This is a common practice in ASP.NET Core to provide context for log messages, making it easier to identify where the
log entries originated from.

This helps in filtering and organizing log messages, especially when dealing with logs from multiple sources.



In production:
Logging at the Trace, Debug, or Information levels produces a high-volume of detailed log messages. To control costs and not exceed data storage limits, log Trace, Debug, or Information level messages to a high-volume, low-cost data store. Consider limiting Trace, Debug, or Information to specific categories.
Logging at Warning through Critical levels should produce few log messages.
Costs and storage limits usually aren't a concern.
Few logs allow more flexibility in data store choices.

In development:
Set to Warning.
Add Trace, Debug, or Information messages when troubleshooting. To limit output, set Trace, Debug, or Information only for the categories under investigation.

If the default log level is not set, the default log level value is Information.<---------------


----------------------------Routing

Route Constraints
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-8.0#route-constraints

Optional Route Parameter
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-8.0#optional-route-parameter-order


----------------------------Handle Errors

https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-8.0

To configure a custom error handling page for the Production environment, call UseExceptionHandler(). This exception handling
middleware:

Catches and logs unhandled exceptions. <----------


IHttpClientFactory integrates with the third-party library Polly

Polly is a comprehensive resilience and transient fault-handling library for .NET.  <---------------------

It allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent
and thread-safe manner.

-----Polly
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0#use-polly-based-handlers



Polly circuit breaker policy

1. Resilience: If _octopusService.GetAwsNonProdAccounts() fails repeatedly (e.g., due to network issues or service downtime),
the circuit breaker will prevent further calls, allowing the service to recover.

constructor
 IResilientPolicyFactory? policyFactory,


 var accounts = await _asyncCircuitBreakerPolicy.ExecuteAsync(
     () => _SomeService.SomeCall());

• Resource Protection: It prevents resource exhaustion by stopping the flow of failing requests.
• Improved Stability: It allows the system to recover from failures, improving overall stability.

-----------------------------------------------------------------------------------

---------------------------- Web apps > Advanced > Filters--------------------------------
https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0

Filters in ASP.NET Core ***allow code to run before or after specific stages** in the **request processing pipeline**.
Filters avoid duplicating code.

Built-in filters handle tasks such as:
  Authorization, preventing access to resources a user isn't authorized for.
  Response caching, short-circuiting the request pipeline to return a cached response.


Custom filters can be created to handle Error handling, caching, configuration, authorization, and logging

Error handling Exception Filter could consolidate error handling

A filter can only indirectly affect a component when:
 The component is embedded in a page or view.
 The page or controller and view uses the filter.

Filter types and execution sequence
https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0#filter-types

Each filter type is executed at a different stage in the filter pipeline

Authorization filters:
 Run first.
  Determine whether the user is authorized for the request.
  Short-circuit the pipeline if the request is not authorized.

Action filters: (can apply to Controllers or Actions)
  Run immediately before and after an action method is called.
  Can change the arguments passed into an action.
  Can change the result returned from the action.
  Are not supported in Razor Pages.

Endpoint filters:
 Run immediately before and after an action method is called.
 Can change the arguments passed into an action.
 Can change the result returned from the action.
 Are not supported in Razor Pages.
 Can be invoked on both actions and route handler-based endpoints.

Result filters:
 Run immediately before and after the execution of action results.
 Run only when the action method executes successfully.
 Are useful for logic that must surround view or formatter execution.
 Eg result filter can add a header to the response

Exception filters apply global policies to unhandled exceptions that occur before the response body has been written to.



Middleware >
    Authorization filters >                   <------------------
       Resource filters >
            Exception filters >               <------------------
                  Model Binding >             <------------------
                     Action filter (Before) > <------------------
                     Action Execution >
		     Action filter (Before) >
                         Result filters


Filter Implementation
Filters support both synchronous and asynchronous implementations through different interface definitions.

Synchronous filters run before and after their pipeline stage. For example, OnActionExecuting is called before
the action method is called. OnActionExecuted is called after the action method returns:

public class SampleActionFilter : IActionFilter  <------
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Do something before the action executes.
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Do something after the action executes.
    }
}

Can add attributes to a Controller or an Action

Attributes allow filters to accept arguments, as shown in the preceding example. Apply the ResponseHeaderAttribute
to a controller or action method and specify the name and value of the HTTP header

[ResponseHeader("Filter-Header", "Filter Value")]
public class ResponseHeaderController : ControllerBase
{


Attribute
In .NET, an attribute is a powerful feature that allows you to add metadata to your code.

Attributes can be applied to
various program elements such as classes, methods, properties, and more. They provide additional information about the
program elements and can be used for various purposes, such as controlling serialization, specifying validation rules,
or providing descriptive information.

Key Points
Metadata: Attributes add metadata to your code, which can be accessed at runtime using reflection.
Custom Attributes: You can create custom attributes by deriving from the System.Attribute class.
Usage: Attributes are specified using square brackets ([ ]) and are placed above the program elements they apply to.

[Author("John Doe", "1.0")] <-- Custom Attibute
public class SampleClass
{

Filters can be applied at 3 levels:
1) Global Level
2) Controller Level
3) Action Level

Filter Usecases: Error handling, caching, configuration, authorization, and logging

Filters can be added by type or by instance.

You can change Filter Execution Order: https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0#override-the-default-order

In ASP.NET Core, filters that are implemented as attributes and added directly to controller classes or action methods
cannot have their constructor dependencies resolved by dependency injection (DI). This is because attributes in .NET are
instantiated by the runtime, not by the DI container.

You need to either use [ServiceFilter] or [TypeFilter] for DI to inject dependencies for the filter





Please show me how to add an ActionFilter globally to a .Net Core Web Api using .Net 8.0 version and Program.cs instead of Startup.cs



[ResponseHeader("Filter-Header", "Filter Value")]   <---------- Controller Level ActionFilter. Will be executed for all Action
public class ResponseHeaderController : ControllerBase
{
    public IActionResult Index() =>
        Content("Examine the response headers using the F12 developer tools.");

    // ...

    [ResponseHeader("Another-Filter-Header", "Another Filter Value")]   <-----Action Level ActionFilter. Only executed for this Action
    public IActionResult Multiple() =>
        Content("Examine the response headers using the F12 developer tools.");
}



Global Action Filter. In Program.cs

// Register the action filter globally
builder.Services.AddControllers(options =>
{
    options.Filters.Add<MyActionFilter>(); =--> will be applied to All Controllers and All Actions
});



Default order of execution
As a result of filter nesting, the after code of filters runs in the reverse order of the before code. The filter sequence:

The before code of global filters.
The before code of controller filters.
The before code of action method filters.
The after code of action method filters.
The after code of controller filters.
The after code of global filters.


The filter pipeline can be short-circuited by setting the Result property on the ResourceExecutingContext parameter provided to the filter method.


Filters can be added by type or by instance.

If an instance is added,
  that instance is used for every request.
If a type is added, it's type-activated. A type-activated filter means:
  An instance is created for each request.
  Any constructor dependencies are populated by dependency injection (DI).

Authorization filters
https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0#authorization-filters

Do not throw exceptions within authorization filters:
  The exception will not be handled.
  Exception filters will not handle the exception.

Automatic HTTP 400 responses: https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-8.0#automatic-http-400-responses
The [ApiController] attribute makes model validation errors automatically trigger an HTTP 400 response. Consequently, the
following code is unnecessary in an action method:
if (!ModelState.IsValid)
{
    return BadRequest(ModelState);
}

IExceptionHandler is used to handle exceptions globally across the entire application. It is typically implemented as
middleware.

IExceptionFilter is used to handle exceptions at the controller or action level.

Exception filters:
 Don't have before and after events.
 Implement OnException or OnExceptionAsync.
 Handle unhandled exceptions that occur in Razor Page or controller creation, model binding, action filters, or action methods.

Exception filters:
 Are good for trapping exceptions that occur within actions.
 Are not as flexible as error handling middleware.

Prefer middleware (IExceptionHandler) for exception handling. Use exception filters only where error handling differs based on
 which action method is called.

Result filters are not executed when:
  An exception filter handles an exception by producing an action result.


---------------------Model Binding
https://learn.microsoft.com/en-us/aspnet/core/mvc/models/model-binding?view=aspnetcore-8.0

The model binding system:

Retrieves data from various sources such as route data, form fields, and query strings.
Provides the data to controllers and Razor pages in method parameters and public properties.
Converts string data to .NET types.
Updates properties of complex types.

Converts the string "2" into integer 2.
Converts the string "true" into boolean true.

After each property is successfully bound, model validation occurs for that property.

ControllerBase.ModelState Or PageModel.ModelState contains
1) the record of what data is bound to the model, and
2) Any Binding errors or
3) Any Validation errors

ModelState.IsValid
To find out if this process was successful, the app checks the ModelState.IsValid flag.

ModelBinding Sources
https://learn.microsoft.com/en-us/aspnet/core/mvc/models/model-binding?view=aspnetcore-8.0#sources

By default, model binding gets data in the form of key-value pairs from the following sources in an HTTP request:
Form fields
The request body (For controllers that have the [ApiController] attribute.)
Route data
Query string parameters
Uploaded files

Route data and query string values are used only for simple types.
Uploaded files are bound only to target types that implement IFormFile or IEnumerable<IFormFile>

If the default source is not correct, use one of the following attributes to specify the source:

[FromQuery] - Gets values from the query string.
[FromRoute] - Gets values from route data.
[FromForm] - Gets values from posted form fields.
[FromBody] - Gets values from the request body.
[FromHeader] - Gets values from HTTP headers.

property name doesn't match the value in the request (Note Vs NoteFromQueryString)
[FromQuery(Name = "Note")]
public string? NoteFromQueryString { get; set; }

For instance, the value in the request might be a header with a hyphen in its name
public void OnGet([FromHeader(Name = "Accept-Language")] string language)

When [FromBody] is applied to a complex type parameter, any binding source attributes
applied to its properties are ignored.


[FromBody]
The ASP.NET Core runtime delegates the responsibility of reading the body to an input formatter.
Input formatters read only the body and don't understand binding source attributes

Don't apply [FromBody] to more than one parameter per action method
Once the request stream is read by an input formatter, it's no longer available to be read again for binding other [FromBody] parameters.

How to get value from cookies using value provider and factory
https://learn.microsoft.com/en-us/aspnet/core/mvc/models/model-binding?view=aspnetcore-8.0#additional-sources

No source for a model property
 Nullable simple types are set to null.
 Non-nullable value types are set to default(T). For example, a parameter int id is set to 0.
 For complex Types, model binding creates an instance by using the default constructor, without setting properties
 Arrays are set to Array.Empty<T>(), except that byte[] arrays are set to null.


form fields -no data found for model binding
If model state should be invalidated, use the [BindRequired] attribute.

Note that this [BindRequired] behavior applies to model binding from posted form data <----
not to JSON or XML data in a  request body.


If ModelBinding is invalid in an API controller marked with [ApiController] attribute
In an API controller that has the [ApiController] attribute, invalid model state results in an
***automatic HTTP 400 response***



public static double FindSimilarity(string x, string y)
{
  if (x == null || y == null) throw new ArgumentException("Strings must not be null");


Several built-in attributes are available for controlling model binding of complex types:
[Bind]
[BindRequired]
[BindNever]

•[ModelBinder(Name = "instructor_id")]: This attribute tells the model binder to bind the Id property from a request
parameter named instructor_id.
{ [ModelBinder(Name = "instructor_id")] public string Id { get; set; }


avoid using index as parameter
 https://learn.microsoft.com/en-us/aspnet/core/mvc/models/model-binding?view=aspnetcore-8.0#collections

input formatters: System.Text.Json and Newtonsoft.Json


TryUpdateModelAsync is typically:
Not used with a web API unless consumed from form data, query strings, and route data. Web API endpoints that consume
JSON use Input formatters to deserialize the request body into an object.


To make the parameter optional, use one of the following approaches:
Make the parameter nullable.
Set a default value for the parameter.

--------------------------Custom Model Binding
https://learn.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-8.0


-------------------------Model Validation
https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0

Web API controllers don't have to check ModelState.IsValid if they have the [ApiController] attribute. In that case, an
automatic HTTP 400 response containing error details is returned when model state is invalid. <---------------------------


----------------------------------------------Best Practices---------------------------------------------------
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/best-practices?view=aspnetcore-8.0

60 Users-Prod

Use asynchronous code whereever possible
Only get as much data as needed via pagesize and pageindex (pagination).
Use IAsyncEnumerable<T> instead of IEnumerable<T>
Do use no-tracking queries in Entity Framework Core when accessing data for read-only purposes. EF Core can return the
    results of no-tracking queries more efficiently.
Do filter and aggregate LINQ queries (with .Where, .Select, or .Sum statements, for example) so that the filtering
    is performed by the database.  <---- For new pages. linq queries (sorting, filtering) performed on database

The following approaches may improve performance in high-scale apps:
 DbContext pooling (Using the AddDbContextPool instead of AddDbContext during service registration services.AddDbContextPool<BloggingContext>(
    options => options.UseSqlServer(connectionString));)
 Explicitly compiled queries- Ef Core - Evaluate: The additional complexity of compiled queries may not justify the performance improvement.
Keep Middleware components fast since they are invoked with each request
Keep other code fast: Code that's executed for every request or multiple times per request. For example, custom logging, authorization handlers, or initialization of transient services.

While reading forms in Actions, use HttpContext.Request.ReadFormAsync instead of HttpContext.Request.Form
var form =  HttpContext.Request.Form; (use synch over async)
ar form = await HttpContext.Request.ReadFormAsync();  <--read the form body asynchronously

Avoid reading large request bodies or response bodies into memory


ASP.NET Core 3.0 uses System.Text.Json by default for JSON serialization. (https://learn.microsoft.com/en-us/aspnet/core/fundamentals/best-practices?view=aspnetcore-8.0#working-with-a-synchronous-data-processing-api)

System.Text.Json:
Reads and writes JSON asynchronously.
Is optimized for UTF-8 text.
Typically is higher performance than Newtonsoft.Json. <--

Do not use 'async void' =>public async void Get().
Use public async Task Get() <= The following example returns a Task to the framework, so the HTTP request doesn't complete until the action completes.


-----------------------------------Security and Identity------------------------------------------
https://learn.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-8.0

The registered authentication handlers and their configuration options are called "schemes".



TODO: Use cookie authentication without ASP.NET Core Identity <------------------------
https://learn.microsoft.com/en-us/aspnet/core/security/authentication/cookie?view=aspnetcore-8.0

Our Authentication Type is JWT (not cookie based) per appsettings.json

https://learn.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-8.0

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(JwtBearerDefaults.AuthenticationScheme,
        options => builder.Configuration.Bind("JwtSettings", options))
    .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme,
        options => builder.Configuration.Bind("CookieSettings", options));

The AddAuthentication parameter JwtBearerDefaults.AuthenticationScheme is the name of the
scheme to use by default when a specific scheme isn't requested.


------Configure Windows Authentication in ASP.NET Core------
https://learn.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth?view=aspnetcore-8.0&tabs=visual-studio

Windows Authentication is a stateful scenario primarily used in an intranet, where a proxy or load balancer doesn't
usually handle traffic between clients and servers.


If a proxy or load balancer is used, Windows Authentication only works if the proxy or load balancer:

Handles the authentication.
Passes the user authentication information to the app (for example, in a request header), which acts on the authentication information.

An alternative to Windows Authentication in environments where proxies and load balancers are used is Active Directory Federated
Services (ADFS) with OpenID Connect (OIDC).


Configuration for launch settings only affects the Properties/launchSettings.json file for IIS Express and doesn't configure IIS
for Windows Authentication.

IIS Express configuration done in launchSettings.json file
IIS for Windows Authentication configuration done in web.config


Hosting ASP.NET Core on Windows with IIS:
https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/?view=aspnetcore-8.0

Difference between WS-Federation and Windows Authentication

The URL you provided points to documentation about WS-Federation, which is a protocol used for federated authentication. Let's break down the differences between WS-Federation and Windows Authentication in simple terms:
WS-Federation
•	Purpose: WS-Federation is used to enable single sign-on (SSO) across different security domains. It allows users to authenticate once and gain access to multiple applications, even if those applications are hosted by different organizations.
•	How It Works: It relies on a trusted identity provider (like Azure AD) to authenticate users. Once authenticated, the identity provider issues a security token that the user can present to other applications to gain access.
•	Use Case: Ideal for scenarios where users need to access multiple applications across different organizations or domains.
Windows Authentication
•	Purpose: Windows Authentication is used to authenticate users based on their Windows credentials (username and password) within a Windows domain.
•	How It Works: It leverages the underlying Windows operating system to authenticate users. This can be done using protocols like NTLM or Kerberos.
•	Use Case: Best suited for intranet environments where users are part of the same Windows domain, such as within a corporate network.

Key Differences
•	Scope: WS-Federation is designed for cross-domain authentication, while Windows Authentication is typically used within a single domain.
•	Identity Provider: WS-Federation uses an external identity provider, whereas Windows Authentication relies on the Windows domain controller.
•	Flexibility: WS-Federation is more flexible for integrating with various applications and services across different organizations, while Windows Authentication is more straightforward for internal corporate environments.

In summary, WS-Federation is for federated authentication across different domains and organizations, while Windows Authentication is for authenticating users within a Windows domain.


Manage JSON Web Tokens in development with dotnet user-jwts
https://learn.microsoft.com/en-us/aspnet/core/security/authentication/jwt-authn?view=aspnetcore-8.0&tabs=windows

The dotnet user-jwts command line tool can create and manage app specific local JSON Web Tokens (JWTs).

Secrets Management
https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-8.0&tabs=windows

This document explains how to manage sensitive data for an ASP.NET Core app on a development machine. Never store passwords or
other sensitive data in source code.

Production secrets shouldn't be used for development or test. Secrets shouldn't be deployed with the app.

Instead, ***production secrets*** should be accessed through a controlled means like
***environment variables*** or <-- environment variables ok? Lokesh
***Azure Key Vault*** <------- AWS equivalent


How to access Secrets in Production using Azure Key Vault
https://learn.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-8.0#use-application-id-and-x509-certificate-for-non-azure-hosted-apps


var builder = WebApplication.CreateBuilder(args);

if (builder.Environment.IsProduction())   <---------------
{
    using var x509Store = new X509Store(StoreLocation.CurrentUser);

    x509Store.Open(OpenFlags.ReadOnly);

    var x509Certificate = x509Store.Certificates
        .Find(
            X509FindType.FindByThumbprint,
            builder.Configuration["AzureADCertThumbprint"],
            validOnly: false)
        .OfType<X509Certificate2>()
        .Single();

    builder.Configuration.AddAzureKeyVault(
        new Uri($"https://{builder.Configuration["KeyVaultName"]}.vault.azure.net/"),
        new ClientCertificateCredential(
            builder.Configuration["AzureADDirectoryId"],
            builder.Configuration["AzureADApplicationId"],
            x509Certificate));
}

-------------------------------------------------Entity Framework----------------------------------------------------

EF Tutorial (Uses VS Code)
https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/

EF Core provides two primary ways of keeping your ***EF Core model*** and ***database schema*** in sync:

1) Migrations (Model as source of truth) - Code First - Don't have an exising database
2) Reverse engineering (Database as source of truth) - Database First - Have an existing database

To choose between these options, decide whether your EF Core model or the database schema is the source of truth.

1) Migrations
When a data model change is introduced, the developer uses EF Core tools to add a corresponding migration. EF Core compares
the current model against a snapshot of the previous model to determine the differences. C# code to implement the changes
is generated. You can modify the C# files for custom behaviors or to seed data.
After a new migration is generated, it can be applied to a database in various ways

2) Reverse engineering
Reverse engineering is the process of scaffolding entity model classes and a DbContext class based on a database schema. This approach
 is often used with existing or shared databases that are managed by a database administrator.


*****In a typical development workflow scenario, you might start with Reverse Engineering if the database already exists, and then use Migrations
for subsequent changes***************

When a data model change is introduced, the developer uses EF Core tools to add a corresponding migration


In Program.cs, TransientService, PizzaService and SingletonService are registered with the ASP.NET Core dependency injection system.

// Register services with different lifetimes
builder.Services.AddTransient<TransientService>();  => A new instance is provided ***every time it is requested***
builder.Services.AddScoped<PizzaService>();         => A new instance is created ***once per request***
builder.Services.AddSingleton<SingletonService>();  => A single instance is created and shared throughout the application's lifetime.

After this in Controller can inject it in constructor parameter

public class PizzaController : ControllerBase
{
    PizzaService _service;

    public PizzaController(PizzaService service)
    {
        _service = service;
    }

difference between ICollection and IEnumerable
•	IEnumerable<T>: Read-only, does not support adding or removing elements.
•	ICollection<T>: Mutable, supports adding and removing elements.

Pizza    Topping
 1   -->  Many
Many <--   1


Pizza  Sauce
 1   -->   1
Many <--   1


<==================================Here 2 of 3
EF Tutorial: https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/

EF Tutorial In Progress- : https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/3-migrations <------------- TODO
check:  For local development, use Secret Manager
Project: C:\Users\dalokman\source\repos\.NetCoreApi-Material\EF-Tutorial\mslearn-persist-data-ef-core\ContosoPizza

EntityFrameworkCore: https://learn.microsoft.com/en-us/ef/core/
EntityFramework: https://learn.microsoft.com/en-us/ef/

Using EF 7.0<---

EF videos
5 videos: https://learn.microsoft.com/en-us/shows/entity-framework-core-101/?wt.mc_id=educationalef-c9-niner
Getting Started with Entity Framework Core: https://www.youtube.com/watch?v=SryQxUeChMc
Working with an Existing Database: https://www.youtube.com/watch?v=DCYVfLT5_QI
ASP.NET Core Web Apps with EF Core: https://www.youtube.com/watch?v=c-wN-fc594c
Database Providers: https://www.youtube.com/watch?v=moRmKo3nrN4
Performance Tips: https://www.youtube.com/watch?v=jgESld7U5Bw





Data Access Tutorials using API???  Only see for Razor and MVC. Applicable??? <-----------------------


dotnet build => to build the app

Cannot use paging and sorting via linq queries when you execute sproc using EF core.
Traditional you can do that on sql server tables and the paging & sorting logic will be executed at db level.

For New pages, when possible just use linq queries since they are composable (can implement paging,sorting and filtering
via linq queries- and the paging/filtering/sorting queries will be executed at db level)

For Existing pages
if existing sproc has paging & sorting logic at sproc level, then just execute.
if existing sproc does not have paging & sorting logic, and if we still want to having paging and sorting,
then just execute and then do paging, sorting and filtering in api memory

    public List<Customer> GetPagedAndSortedCustomers(string sortBy, bool ascending, int pageNumber, int pageSize)
    {
        // Step 1: Execute the stored procedure to get the data
        var customers = _context.Customers.FromSqlRaw("EXEC GetCustomers").ToList();  <--- Use AsNoTracking()

        // Step 2: Apply sorting
        if (ascending)
        {
            customers = customers.OrderBy(c => EF.Property<object>(c, sortBy)).ToList();
        }
        else
        {
            customers = customers.OrderByDescending(c => EF.Property<object>(c, sortBy)).ToList();
        }

        // Step 3: Apply paging
        var pagedCustomers = customers
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToList();

        return pagedCustomers;
    }

Use AsNoTracking when executing Sprocs since don't need entities to be tracked by EF. More faster
Sprocs used for CRUD=> create, read, update and delete

var results = context.AdvConvDashboardResponseRecords
    .FromSqlRaw("EXEC dbo.GetAdvConvDashboardResponseRecords")
    .AsNoTracking()  <-----------------------------------------------------------
    .ToList();


Paging: https://learn.microsoft.com/en-us/ef/core/performance/efficient-querying


Copilot- Linq query: paging, sorting, filtering

// Models/Product.cs
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Category { get; set; }
}

// Data/ApplicationDbContext.cs
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }

    public DbSet<Product> Products { get; set; }
}

// Controllers/ProductsController.cs
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly ApplicationDbContext _context;

    public ProductsController(ApplicationDbContext context)
    {
        _context = context;
    }

    [HttpGet]
    public async Task<IActionResult> GetProducts(
        string? category = null,
        string? sortBy = "Name",
        bool ascending = true,
        int pageNumber = 1,
        int pageSize = 10)
    {
        var query = _context.Products.AsQueryable();

        // Filtering
        if (!string.IsNullOrEmpty(category))
        {
            query = query.Where(p => p.Category == category);
        }

        // Sorting
        query = sortBy switch
        {
            "Price" => ascending ? query.OrderBy(p => p.Price) : query.OrderByDescending(p => p.Price),
            "Name" => ascending ? query.OrderBy(p => p.Name) : query.OrderByDescending(p => p.Name),
            _ => query.OrderBy(p => p.Name)
        };

        // Paging
        var totalItems = await query.CountAsync();
        var products = await query
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        var result = new
        {
            TotalItems = totalItems,
            PageNumber = pageNumber,
            PageSize = pageSize,
            Items = products
        };

        return Ok(result);
    }
}


Microsoft Docs- Official paging, sorting, filtering in MVC Controller

https://github.com/dotnet/AspNetCore.Docs/blob/main/aspnetcore/data/ef-mvc/intro/samples/cu-final/Controllers/StudentsController.cs


















Data Access Logic
How to Execute Stored Procedures and map to .Net objects:
1) Use EF Core (with Automapper). EFCore may be able to map to .Net DTO objects as well. https://learn.microsoft.com/en-us/ef/core/querying/sql-queries
2) Use Dapper (with Automapper).

ADO.net old way: https://stackoverflow.com/questions/28599404/how-to-run-stored-procedures-in-entity-framework-core

One of the project uses ADO.net to execute sproc
C:\Users\dalokman\source\repos

copilot prompt: 'can you use Automapper, Dapper and EntityFramework Core together in the same project?'


Both functions use Automapper. First one uses EF and second one uses Dapper.

    public List<CustomerDTO> GetCustomersUsingEF()
    {
        var customers = _context.Customers.ToList();
        return _mapper.Map<List<CustomerDTO>>(customers);
    }

    public List<CustomerDTO> GetCustomersUsingDapper()
    {
        string sql = "SELECT Id, Name, Email, PhoneNumber, Address FROM Customers";
        var customers = _dbConnection.Query<Customer>(sql).ToList();
        return _mapper.Map<List<CustomerDTO>>(customers);

//////////////////////////EF Core Tutorial: https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/

Both:
Apply code migration to update Database
Reverse engineer from existing database

Uses 2 databases. Different Context

EF Tutorial: https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core
EF Tutorial In Progress- : https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/3-migrations

Entity Framework Core (EF Core) is an object-relational mapper (ORM). An ORM provides a layer between the domain model that you
implement in code and a database. EF Core is a data access API that allows you to interact with the database by using .NET plain old
Common Runtime Language (CLR) objects (POCOs) and strongly typed Language Integrated Query (LINQ) syntax.

DbContext    => DbSet => methods to configure options, connection strings, logging, and the model that's used to map your domain to the database.
EF Core Provider      => The EF Core Provider translates object graph changes to SQL.
Database Provider     => Is a plug-in library that's designed for a specific database engine, such as SQL Server, Azure Cosmos DB, or PostgreSQL.
		         Translates method calls and LINQ queries to the database's native SQL dialect.
Database

Include properties of type DbSet<T> that represent tables in the database.

The EF Core Provider translates object graph changes to SQL.

Manage database schemas:
EF Core provides two primary ways of keeping your EF Core model and database schema in sync:
1) Migrations (model as source of truth)
2) Reverse engineering (database as source of truth)


***Migrations***
The EF Core migrations feature provides a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database.

When a data model change is introduced, the developer uses EF Core tools to add a corresponding migration.
EF Core compares the current model against a snapshot of the previous model to determine the differences.
C# code to implement the changes is generated. <====
You can modify the C# files for custom behaviors or to seed data.  <===
The files are tracked in your project's source control like any other source file.

After a new migration is generated, it can be applied to a database in various ways.
EF Core records all applied migrations in a special history table.
The history table keeps a record of which migrations have been applied.


***Reverse engineering***
Reverse engineering is the process of scaffolding entity model classes and a DbContext class based on a
database schema. This approach is often used with existing or shared databases that are managed by a
database administrator.


Database providers in EF Core are pluggable. <=====
SQLite is a good choice for this module because it's lightweight and cross-platform.
You can use the same code to work with different database engines, such as SQL Server and PostgreSQL. <=====
You can even use multiple database engines in the same app. <==============

EF Core SQLite database provider and all its dependencies: dotnet add package Microsoft.EntityFrameworkCore.Sqlite
EF Core tools : dotnet add package Microsoft.EntityFrameworkCore.Design (dependency of Microsoft.EntityFrameworkCore.Tools. Included with it**)
dotnet-ef: The tool you'll use to create migrations and scaffolding



what is the difference between Microsoft.EntityFrameworkCore.Tools and Microsoft.EntityFrameworkCore.Design?


Microsoft.EntityFrameworkCore.Tools
•	Purpose: This package provides command-line tools for Entity Framework Core. These tools are used for tasks such as database migrations, scaffolding, and updating the database schema.
•	Usage: Typically used in the development environment to run commands like dotnet ef migrations add or dotnet ef database update.

Microsoft.EntityFrameworkCore.Design (dependency of Microsoft.EntityFrameworkCore.Tools. Included with it**)
•	Purpose: This package contains design-time utilities for Entity Framework Core. It includes components that are necessary for design-time features such as scaffolding (reverse engineering) and migrations.
•	Usage: Required by the tools to perform design-time tasks. It is not typically used directly by developers but is necessary for the tools to function correctly.
•	Integration: It provides the necessary infrastructure for the Microsoft.EntityFrameworkCore.Tools to perform its operations.

•	Microsoft.EntityFrameworkCore.Tools: Provides command-line tools for EF Core.
•	Microsoft.EntityFrameworkCore.Design: Provides design-time utilities required by the ***tools*** <=====================

sample project
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.2" />           => EF Core
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.2" /> => Sql Server Database Provider
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.2">       => database migrations, scaffolding, and updating the database schema.

Microsoft.EntityFrameworkCore.Tools and Microsoft.EntityFrameworkCore.Design are both packages that help with design-time development tasks
for Entity Framework Core (EF Core)


Scaffold models and DbContext  <===============TODO next
https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/3-migrations

Like ASP.NET Core MVC, EF Core uses a convention over configuration approach.

EF Core conventions shorten development time by inferring the developer's intent. For example, EF core infers a property named Id or
<entity name>Id to be the generated table's primary key.

If you choose not to adopt the naming convention,
1) you must annotate the property with the [Key] attribute OR
2) configure it as a key in the OnModelCreating method of the DbContext.



//  to generate a migration called 'xxx_InitialCreate' for creating the database tables
dotnet ef migrations add InitialCreate --context PizzaContext

// to apply the InitialCreate migration
dotnet ef database update --context PizzaContext



//  to generate a migration called 'xxx_ModelRevisions' for creating the database tables
dotnet ef migrations add ModelRevisions --context PizzaContext

//  to apply the ModelRevisions migration
dotnet ef database update --context PizzaContext


2 ways to map models to database (Can use both. Data Annotations for simple configurations and Fluent API for more complex configurations or where Data Annotations fall short)
1) Mapping attributes (data annotations) to map models to the database
2) ModelBuilder fluent API to configure models (configuration on OnModelCreating method)
Both approaches are valid, but some developers prefer one approach over the other.

You can use Data Annotations for simple configurations and Fluent API for more complex configurations or where Data Annotations fall short.
This approach allows you to leverage the strengths of both methods.

Fluent API Advantages:
•	More expressive and flexible.
•	Can configure relationships, keys, and constraints that are not possible with Data Annotations.
•	Keeps the entity classes clean and focused on business logic.

Data Annotations Advantages:
•	Simpler and more concise for basic configurations.
•	Keeps configuration close to the entity properties, making it easier to see at a glance.
•	Useful for simple validation rules and constraints.

The AsNoTracking extension method instructs EF Core to disable change tracking.
Because this operation is read-only, AsNoTracking can optimize performance.

The Include extension method takes a lambda expression to specify that the Toppings and Sauce navigation properties
are to be included in the result by using eager loading. Without this expression, EF Core returns null for those properties.

public Pizza? GetById(int id)
{
    return _context.Pizzas
        .Include(p => p.Toppings)
        .Include(p => p.Sauce)
        .AsNoTracking()
        .SingleOrDefault(p => p.Id == id);
}




https://github.com/dotnet/efcore

///////////////////////////////////////////////Ene EF Core Tutorial: https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/

Microsoft.EntityFrameworkCore
EF 7.0.13
EF 8.0.2


-------------------------------------------------EntityFrameworkCore---------------------------------------------
https://learn.microsoft.com/en-us/ef/core/

Entity Framework (EF) Core is a lightweight, extensible, open source and cross-platform version of the popular
Entity Framework data access technology

EF supports the following model development ***approaches***:
1) Generate a model from an existing database. [Reverse engineering (Database as source of truth) - Database First - Have an existing database]
2) Hand code a model to match the database.   <-------------------------
3) Generate a database from a model.           [Migrations (Model as source of truth) - Code First - Don't have an exising database]
   Once a model is created, use EF Migrations to create a database from the model. Migrations allow evolving the database as the model changes.

*****In a typical development workflow scenario, you might start with Reverse Engineering if the database already exists, and then
use Migrations for subsequent changes***************

1) Migrations
When a data model change is introduced, the developer uses EF Core tools to add a corresponding migration. EF Core compares
the current model against a snapshot of the previous model to determine the differences. C# code to implement the changes
is generated. You can modify the C# files for custom behaviors or to seed data.
After a new migration is generated, it can be applied to a database in various ways

2) Reverse engineering
Reverse engineering is the process of scaffolding entity model classes and a DbContext class based on a database schema. This approach
 is often used with existing or shared databases that are managed by a database administrator.



public class BloggingContext : DbContext
{
    public DbSet<Blog> Blogs { get; set; }
    public DbSet<Post> Posts { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(
            @"Server=(localdb)\mssqllocaldb;Database=Blogging;Trusted_Connection=True;ConnectRetryCount=0");
    }
}

public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
    public int Rating { get; set; }
    public List<Post> Posts { get; set; }  <---------------
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public int BlogId { get; set; }       <---------------
    public Blog Blog { get; set; }        <---------------
}

https://learn.microsoft.com/en-us/ef/core/#ef-orm-considerations
EF O/RM considerations

Should have knowledge of primary and foreign keys, constraints, indexes, normalization, DML and DDL statements, data types, profiling
Catch breaking changes when upgrading EF Core and other dependencies. For example, adding or upgrading frameworks like ASP.NET Core, OData, or AutoMapper.
  These dependencies can affect EF Core in unexpected ways.
Performance and stress testing with representative loads. The naïve usage of some features doesn't scale well. For example, multiple
  collections Includes, heavy use of lazy loading, conditional queries on non-indexed columns, massive updates and inserts with
  store-generated values, lack of concurrency handling, large models, inadequate cache policy.
Security review: For example, handling of connection strings and other secrets, database permissions for non-deployment operation,
  input validation for raw SQL, encryption for sensitive data.

Objects saved to the database can be split into three broad categories:
Objects that are unstructured and hold a single value. For example, int, Guid, string, IPAddress. These are (somewhat loosely) called "primitive types".
Objects that are structured to hold multiple values, and where the identity of the object is defined by a key value. For example, Blog, Post, Customer. These are called "entity types".
Objects that are structured to hold multiple values, but the object has no key defining identity. For example, Address, Coordinate.

Prior to EF8, there was no good way to map the third type of object.

EF8 now supports "Complex Types" to cover this third type of object.


Complex Types - What's New in EF Core 8
https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-8.0/whatsnew

Complex type objects:
Are not identified or tracked by key value.
Must be defined as part of an entity type. (In other words, you cannot have a DbSet of a complex type.)
Can be either .NET value types or reference types.
Instances can be shared by multiple properties.



In C#, the required keyword is used to indicate that a property must be initialized during object creation.


public class Customer
{
    public int Id { get; set; }
    public required string Name { get; set; }
    public required Address Address { get; set; }
    public List<Order> Orders { get; } = new();
}
public class Address    (Complex Type)
{
    public required string Line1 { get; set; }
    public string? Line2 { get; set; }
    public required string City { get; set; }
    public required string State { get; set; }
    public required string ZipCode { get; set; }
}
• required: This keyword ensures that the Line1, City, State, and ZipCode properties must be initialized when an instance of the Address class is created.
• string? Line2: This property is optional and does not need to be initialized during object creation.

var address = new Address
{
    Line1 = "123 Main St",
    City = "Anytown",
    State = "CA",
    ZipCode = "12345"
};

var customer = new Customer
{
    Name = "Willow",
    Address = new() { Line1 = "Barking Gate", City = "Walpole St Peter", Country = "UK", PostCode = "PE14 7AV" }
};


EF Core Limitation************ <--------------------Maybe alot more other limitations as well
https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-8.0/whatsnew#simple-example
Complex type like Address above that do not have a Id key (Unique Identifier) are not stored in their own tables (as of right now)
and are stored in parent table.
Eg Address info is stored as columns in Customer table even though Customer and Address have different
classes (and Address does not have an ID)

INSERT INTO [Customers] ([Name], [Address_City], [Address_Country], [Address_Line1], [Address_Line2], [Address_PostCode])
OUTPUT INSERTED.[Id]
VALUES (@p0, @p1, @p2, @p3, @p4, @p5);

On the other hand, sharing the same instance between complex properties is allowed, and so the code works as expected when
using complex types.


Complex Type => Out of Scope since database already exists. Cannot modify



Configuration of complex types: Either via Attributes or Fluent API

[ComplexType]
public class Address
{
    public required string Line1 { get; set; }
    public string? Line2 { get; set; }
    public required string City { get; set; }
    public required string Country { get; set; }
    public required string PostCode { get; set; }
}

Or


protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Customer>()
        .ComplexProperty(e => e.Address);

    modelBuilder.Entity<Order>(b =>
    {
        b.ComplexProperty(e => e.BillingAddress);
        b.ComplexProperty(e => e.ShippingAddress);
    });
}



public class Address
{
    public Address(string line1, string? line2, string city, string country, string postCode)
    {
        Line1 = line1;
        Line2 = line2;
        City = city;
        Country = country;
        PostCode = postCode;
    }

    public string Line1 { get; }
    public string? Line2 { get; }
    public string City { get; }
    public string Country { get; }
    public string PostCode { get; }
}

C#
With C# 12 or above, this class definition can be simplified using a primary constructor:
In C#, The with statement is typically used with record types
 The with statement is useful for working with immutable objects, where you want to create a modified copy without changing the
 original object. <-------------------
In C#, a struct (short for structure) is a value type, not a reference type.
However, mutable structs are generally discouraged in C#, so think very carefully before using them.

public class Address(string line1, string? line2, string city, string country, string postCode)
{
    public string Line1 { get; } = line1;
    public string? Line2 { get; } = line2;
    public string City { get; } = city;
    public string Country { get; } = country;
    public string PostCode { get; } = postCode;
}

For example, Address can be defined such that it can not be modified:
public readonly struct Address(string line1, string? line2, string city, string country, string postCode)
{
    public string Line1 { get; } = line1;
    public string? Line2 { get; } = line2;
    public string City { get; } = city;
    public string Country { get; } = country;
    public string PostCode { get; } = postCode;
}

C# 10 introduced struct record types, which makes it easy to create and work with immutable struct records like it is with immutable class records.
public readonly record struct Address(string Line1, string? Line2, string City, string Country, string PostCode);

Note that projections of complex types cannot be tracked, since complex type objects have no identity to use for tracking.


-------------Raw SQL queries for unmapped types:  https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-8.0/whatsnew#raw-sql-queries-for-unmapped-types

Unmapped types are classes that are not part of your EF Core model. These types do not have corresponding DbSet properties in your
DbContext and are not tracked by EF Core. They are typically used for read-only operations where you need to retrieve data but do
not need to update it.

EF7 introduced raw SQL queries returning scalar types.
Queries using unmapped types are executed using SqlQuery or SqlQueryRaw.  <-----------------------------------------


CREATE TABLE [Posts] (
    [Id] int NOT NULL IDENTITY,
    [Title] nvarchar(max) NOT NULL,
    [Content] nvarchar(max) NOT NULL,
    [PublishedOn] date NOT NULL,               <----------
    [BlogId] int NOT NULL,
);


public class BlogPost
{
    public int Id { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }
    public DateOnly PublishedOn { get; set; }   <---------
    public int BlogId { get; set; }
}

 [Column("Title")]  <--- in DB its Title
 public string BlogTitle { get; set; }


var start = new DateOnly(2022, 1, 1);
var end = new DateOnly(2023, 1, 1);
var postsIn2022 =
    await context.Database
        .SqlQuery<BlogPost>($"SELECT * FROM Posts as p WHERE p.PublishedOn >= {start} AND p.PublishedOn < {end}")
        .ToListAsync();



The type used for query results

public class BlogPost
{
    public BlogPost(string blogTitle, string content, DateOnly publishedOn)
    {
        BlogTitle = blogTitle;
        Content = content;
        PublishedOn = publishedOn;
    }

    public int Id { get; private set; }   <-------------------

    [Column("Title")]
    public string BlogTitle { get; set; }

    public string Content { get; set; }
    public DateOnly PublishedOn { get; set; }
    public int BlogId { get; set; }
}

Note
Types used in this way do not have keys defined and cannot have relationships to other types.

Types with relationships must be mapped in the model. <-------------------



The type used must have a property for every value in the result set, but do not need to match any table in the database.


public class PostSummary
{
    public string BlogName { get; set; } = null!;
    public string PostTitle { get; set; } = null!;
    public DateOnly? PublishedOn { get; set; }
}

var cutoffDate = new DateOnly(2022, 1, 1);
var summaries =
    await context.Database.SqlQuery<PostSummary>(
            @$"SELECT b.Name AS BlogName, p.Title AS PostTitle, p.PublishedOn
               FROM Posts AS p
               INNER JOIN Blogs AS b ON p.BlogId = b.Id
               WHERE p.PublishedOn >= {cutoffDate}")
        .ToListAsync();


One nice feature of SqlQuery is that it returns an IQueryable which can be composed on using LINQ <---------------SqlQuery returns IQueryable

var summariesIn2022 =
    await context.Database.SqlQuery<PostSummary>(
            @$"SELECT b.Name AS BlogName, p.Title AS PostTitle, p.PublishedOn
               FROM Posts AS p
               INNER JOIN Blogs AS b ON p.BlogId = b.Id")
        .Where(p => p.PublishedOn >= cutoffDate && p.PublishedOn < end)
        .ToListAsync();


At this point it is worth remembering that all of the above can be done completely in LINQ without the need to write any SQL. This
includes returning instances of an unmapped type like PostSummary.


var summaries =
    await context.Posts.Select(
            p => new PostSummary
            {
                BlogName = p.Blog.Name,
                PostTitle = p.Title,
                PublishedOn = p.PublishedOn,
            })
        .Where(p => p.PublishedOn >= start && p.PublishedOn < end)
        .ToListAsync();

EF is able to generate cleaner SQL when it is responsible for the entire query than it is when composing over user-supplied SQL because, in the
former case, the full semantics of the query is available to EF.



Ref: https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-8.0/whatsnew#raw-sql-queries-for-unmapped-types

Querying View using SqlQuery without mapping the view type in the EF model. For example: <-------- Querying View using SqlQuery (returns IQueryable)

var summariesFromView =
    await context.Database.SqlQuery<PostSummary>(
            @$"SELECT * FROM PostAndBlogSummariesView")
        .Where(p => p.PublishedOn >= cutoffDate && p.PublishedOn < end)
        .ToListAsync();


Querying Function using SqlQuery  <---------  Querying Function using SqlQuery (returns IQueryable)

var summariesFromFunc =
    await context.Database.SqlQuery<PostSummary>(
            @$"SELECT * FROM GetPostsPublishedAfter({cutoffDate})")
        .Where(p => p.PublishedOn < end)
        .ToListAsync();


Querying Stored Procedure using SqlQuery  <----  Querying Stored Procedure using SqlQuery (but most databases do not support composing over them - No IQueryable. Verify Sql Server)

var summariesFromStoredProc =
    await context.Database.SqlQuery<PostSummary>(
            @$"exec GetRecentPostSummariesProc")
        .ToListAsync();

EF8 adds support for lazy-loading of navigations on entities that are not being tracked by the DbContext.

This means a no-tracking query can be followed by lazy-loading of navigations on the entities returned by the no-tracking query.


If Blog.Posts is configured for lazy-loading, for example, using lazy-loading proxies, then accessing Posts will cause it to
load from the database:
 foreach (var post in blogs[blogId - 1].Posts)
    {
        Console.WriteLine($"  {post.Title}");
    }

Lazy Loading is synchronous
Remember that all lazy-loading uses synchronous I/O, since there is no way to access a property in an asynchronous manner.

EF8 supports loading of navigations on untracked entities even when the entity or navigation is not configured for lazy-loading.
Unlike with lazy-loading, this explicit loading can be done asynchronously. For example:

await context.Entry(blog).Collection(e => e.Posts).LoadAsync();


In classic EF6 applications, a common source of bugs is forgetting to make a navigation virtual, since the navigation will then
silently not lazy-load.

EF8 has support for DateOnly and TimeOnly as properties in entity types. (no time)


public class School
{
    public int Id { get; set; }
    public string Name { get; set; } = null!;
    public DateOnly Founded { get; set; }    <-------------------  C# DateOnly
    public List<Term> Terms { get; } = new();
    public List<OpeningHours> OpeningHours { get; } = new();
}

CREATE TABLE [Schools] (
    [Id] int NOT NULL IDENTITY,
    [Name] nvarchar(max) NOT NULL,
    [Founded] date NOT NULL,                  <-------------------- Sql 'date' type
    CONSTRAINT [PK_Schools] PRIMARY KEY ([Id]));



[Owned]
public class OpeningHours
{
    public OpeningHours(DayOfWeek dayOfWeek, TimeOnly? opensAt, TimeOnly? closesAt)
    {
        DayOfWeek = dayOfWeek;
        OpensAt = opensAt;
        ClosesAt = closesAt;
    }

    public DayOfWeek DayOfWeek { get; private set; }
    public TimeOnly? OpensAt { get; set; }        <------------------ C# TimeOnly
    public TimeOnly? ClosesAt { get; set; }
}



CREATE TABLE [OpeningHours] (
    [SchoolId] int NOT NULL,
    [Id] int NOT NULL IDENTITY,
    [DayOfWeek] int NOT NULL,
    [OpensAt] time NULL,                          <------------------- Sql 'time' type
    [ClosesAt] time NULL,
    CONSTRAINT [PK_OpeningHours] PRIMARY KEY ([SchoolId], [Id]),
    CONSTRAINT [FK_OpeningHours_Schools_SchoolId] FOREIGN KEY ([SchoolId]) REFERENCES [Schools] ([Id]) ON DELETE CASCADE);


Starting with EF Core 8.0, date and time in Sqlserver are scaffolded as DateOnly and TimeOnly in C#

By default, SQL Server uses case-insensitive comparisons when comparing foreign key values for matches to principal key values.

---------------Installing Entity Framework Core
https://learn.microsoft.com/en-us/ef/core/get-started/overview/install

Microsoft.EntityFrameworkCore.Tools => to carry out EF Core-related tasks in your project, like creating and applying
database migrations, or creating an EF Core model based on an existing database.


Two sets of tools are available:
The .NET Core command-line interface (CLI) tools can be used on Windows, Linux, or macOS. These commands begin with dotnet ef.
The Package Manager Console (PMC) tools run in Visual Studio on Windows. These commands start with a verb, for example Add-Migration,
Update-Database.


Microsoft.EntityFrameworkCore.Design =>  It provides design-time tools and services that are used primarily during the development
 phase of an application. These tools are crucial for tasks such as scaffolding, migrations, and other design-time operations.


 Microsoft.EntityFrameworkCore.Tools => To get the Package Manager Console tools for EF Core
 Microsoft.EntityFrameworkCore.SqlServer

In C# 8.0 and later, you can use the using declaration without the need for braces {}. This syntax ensures that the resource is
disposed of at the end of the scope in which it is declared.

using var db = new BloggingContext();   <------------------------No open and closed brackets. automatically will be disposed when enclosing function finishes

// Use db within this scope
var blogs = db.Blogs.ToList();



--https://csharp.christiannagel.com/2019/04/09/using/
private static void NewResourceReturned()
{
    using var _ = GetTheResource();
    // do something here
}  // resource is disposed here.


At the end of the scope of the variable r (which is here the end of the method), the Dispose method is invoked.

private static void NewWithUsingDeclaration()
{
    using var r = new AResource();
    r.UseIt();
}


EF Core Database Providers: https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli


------------- DbContext Lifetime, Configuration, and Initialization

https://learn.microsoft.com/en-us/ef/core/dbcontext-configuration/

context class and entity classes

Context
Entities (context.Tablename. Tracked by EF) => For new pages
DTOs     (execute sproc. Not tracked by EF. also called Unmapped types). SqlQuery or SqlQueryRaw.  (FromSqlRaw- check can you get IQueryable)


The lifetime of a DbContext begins when the instance is created and ends when the instance is disposed.

UnitOfWork
org:LLL-Development .GetRepository language:C#

UnitOfWork: https://www.martinfowler.com/eaaCatalog/unitOfWork.html
A Unit of Work keeps track of everything you do during a business transaction that can affect the database. When you're done, it figures out
everything that needs to be done to alter the database as a result of your work.


A typical unit-of-work when using Entity Framework Core (EF Core) involves:

Creation of a DbContext instance
Tracking of entity instances by the context. Entities become tracked by
  Being returned from a query
    var blog = context.Blogs.SingleOrDefault(b => b.BlogId == 1);
    blog.Rating = 5;
    context.SaveChanges();
  Being added or attached to the context
Changes are made to the tracked entities as needed to implement the business rule
SaveChanges or SaveChangesAsync is called. EF Core detects the changes made and writes them to the database.
The DbContext instance is disposed

***Important***
It is very important to dispose the DbContext after use.  (Using statement)
DbContext is not thread-safe. Do not share contexts between threads. Make sure to await all async calls before continuing to use the context instance.
An InvalidOperationException thrown by EF Core code can put the context into an unrecoverable state. Such exceptions indicate a program error and are not designed to be recovered from.

This example registers a DbContext subclass called ApplicationDbContext as a ***scoped service*** in the ASP.NET Core application service provider
 services.AddDbContext<ApplicationDbContext>(
        options => options.UseSqlServer("name=ConnectionStrings:DefaultConnection"));

scoped service => A new instance is created ***once per request***


public class MyController
{
    private readonly ApplicationDbContext _context;

    public MyController(ApplicationDbContext context)
    {
        _context = context;
    }
}


The final result is an ApplicationDbContext instance created for each request and passed to the controller to perform a
unit-of-work before being disposed when the request ends.




https://learn.microsoft.com/en-us/ef/core/dbcontext-configuration/#configuring-the-database-provider
Configuring the database provider
Each DbContext instance must be configured to use one and only one database provider.
 (Different instances of a DbContext subtype can be used with different database providers, but a single instance must only use one.)

public class ApplicationDbContext : DbContext
{
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        // Configuring the database provider
        optionsBuilder.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=Test;ConnectRetryCount=0");
    }
}


ConnectionStrings : https://learn.microsoft.com/en-us/ef/core/miscellaneous/connection-strings
The connection string could be stored in
appsettings.json, an environment variable, the user secret store, or another configuration source
transient =>  A new instance is provided ***every time it is requested***

DbContext Pooling & Others (Performance)
EF Core can pool your context instances: when you dispose your context, EF Core resets its state and stores it in an internal pool; when a new instance is next requested, that pooled instance is returned instead of setting up a new one
https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics?tabs=with-di%2Cexpression-api-with-constant#dbcontext-pooling


---------------Creating a Model
https://learn.microsoft.com/en-us/ef/core/modeling/

EF Core uses a metadata model to describe how the ***application's entity types*** are mapped to the ***underlying database***

This is built using a set of conventions - heuristics that look for common patterns.

Default: Use Conventions for mapping Entities to DB
   Override using  mapping attributes (also known as Data Annotations)    and/or <----- 'and' is ok. Can use both Data Annotations & Fluent API
   Calls to the ModelBuilder methods (also known as fluent API) in OnModelCreating


Fluent API configuration has the highest precedence and will override Conventions and Data Annotations <-------

**OnModelCreating**
The configuration is applied in the order the methods are called and if there are any conflicts the latest call will
override previously specified configuration.


Data annotations will override conventions, but will be overridden by Fluent API configuration. <-------------

Conventions: https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.conventions.iconvention?view=efcore-8.0



public class BooksContext : DbContext
{
    public DbSet<Book> Books { get; set; }

is equivalent to

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Book>();
}

Can remove a convention if not needed: https://learn.microsoft.com/en-us/ef/core/modeling/#example-dont-create-indexes-for-foreign-key-columns

Eg Index for ForeignKeyIndexConvention.


------------ Entity Types
https://learn.microsoft.com/en-us/ef/core/modeling/entity-types?tabs=data-annotations


Including a DbSet of a type on your context means that it is included in EF Core's model; we usually refer to such a type as an entity


public class BooksContext : DbContext
{
    public DbSet<Book> Books { get; set; }


Book is an Entity that is included in EF Core's model

To Exclude a class from EF Core's model so its not mapped to DB

[NotMapped]
public class BlogMetadata
{
    public DateTime LoadedFromDatabase { get; set; }
}

Or

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Ignore<BlogMetadata>();
}


By convention, each entity type will be set up to map to a database table with the same name as the DbSet property that exposes the entity.

[Table("blogs")] => Blog is mapped to blogs table in the database
public class Blog
Or
modelBuilder.Entity<Blog>().ToTable("blogs");


View mapping  <----- can map to Views
https://learn.microsoft.com/en-us/ef/core/modeling/entity-types?tabs=fluent-api#view-mapping

Entity types can be mapped to database views using the Fluent API.

modelBuilder.Entity<Blog>().ToView("blogsView", schema: "blogging");


Table-valued function mapping  <------ can map to Table-valued function
https://learn.microsoft.com/en-us/ef/core/modeling/entity-types?tabs=fluent-api#table-valued-function-mapping
Note: In order to map an entity to a table-valued function the function must be parameterless.


---Included and excluded properties

public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }

    [NotMapped]
    public DateTime LoadedFromDatabase { get; set; }
}
Or

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .Ignore(b => b.LoadedFromDatabase);  <--- Ignore
}

---Column names

public class Blog
{
    [Column("blog_id")] <-- column name in db table
    public int BlogId { get; set; }
Or
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .Property(b => b.BlogId)
        .HasColumnName("blog_id");
}


---Column data types  <--- Can specify exact column data types if don't match with EF conventions
When using a relational database, the database provider selects a data type based on the .NET type of the property.

For example, SQL Server maps DateTime properties to datetime2(7) columns, and string properties
to nvarchar(max) columns (or to nvarchar(450) for properties that are used as a key).

You can also configure your columns to specify an exact data type for a column.

For example, the following code configures Url as a non-unicode string with maximum length of 200 and Rating as decimal with precision of 5 and scale of 2:

public class Blog
{
    public int BlogId { get; set; }

    [Column(TypeName = "varchar(200)")]  <-- by convention, default is nvarchar(max)
    public string Url { get; set; }

    [Column(TypeName = "decimal(5, 2)")]
    public decimal Rating { get; set; }
}
OR
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>(
        eb =>
        {
            eb.Property(b => b.Url).HasColumnType("varchar(200)");
            eb.Property(b => b.Rating).HasColumnType("decimal(5, 2)");
        });
}


--Maximum length
 [MaxLength(500)]
    public string Url { get; set; }


----Required and optional properties  (Table column: null vs not null)
A property is considered optional if it is valid for it to contain null.
If you cannot assign null, then property is required

When mapping to a relational database schema, required properties are created as non-nullable columns,
and optional properties are created as nullable columns.

C# 8 introduced a new feature called nullable reference types (NRT)

It is enabled by default and thus
string? will be configured as optional, but string will be configured as required.


If NRT (nullable reference types ) is enabled (Default) <-----

public class Customer
{
    public int Id { get; set; }
    public string FirstName { get; set; } // Required by convention
    public string LastName { get; set; } // Required by convention
    public string? MiddleName { get; set; } // Optional by convention

    // Note the following use of constructor binding, which avoids compiled warnings
    // for uninitialized non-nullable properties.
    public Customer(string firstName, string lastName, string? middleName = null)
    {
        FirstName = firstName;
        LastName = lastName;
        MiddleName = middleName;
    }
}

If NRT (nullable reference types ) is disabled <-----

public class CustomerWithoutNullableReferenceTypes
{
    public int Id { get; set; }

    [Required] // Data annotations needed to configure as required <---need Required
    public string FirstName { get; set; }

    [Required] // Data annotations needed to configure as required
    public string LastName { get; set; }

    public string MiddleName { get; set; } // Optional by convention
}


--- Explicit configuration

A property that would be optional by convention can be configured to be required as follows:

public class Blog
{
    public int BlogId { get; set; }

    [Required]
    public string Url { get; set; }
}


--EF owned types

 Keys: https://learn.microsoft.com/en-us/ef/core/modeling/keys?tabs=data-annotations

By convention, a property named Id or <type name>Id will be configured as the primary key of an entity.

[Key]
public string LicensePlate { get; set; }
Or
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasKey(c => c.LicensePlate);
}

CompositeKey

[PrimaryKey(nameof(State), nameof(LicensePlate))]
internal class Car
{
    public string State { get; set; }
    public string LicensePlate { get; set; }


---Alternate Keys
https://learn.microsoft.com/en-us/ef/core/modeling/keys?tabs=fluent-api#alternate-keys

-- Generated Values


model-building API  overrides convention or data annotations(mapping attributes)

model-building API
data annotations
convention




public Blog Blog { get; set; } = null!;    // This property is not null



************1 to many relationship**************

// Principal (parent)
public class Blog
{
    public int Id { get; set; }
    public ICollection<Post> Posts { get; } = new List<Post>(); // Collection navigation containing dependents
}

// Dependent (child)
public class Post
{
    public int Id { get; set; }
    public int BlogId { get; set; } // Required foreign key property
    public Blog Blog { get; set; } = null!; // Required reference navigation to principal
}



        modelBuilder.Entity<Blog>()
        .HasMany(e => e.Posts)
        .WithOne(e => e.Blog)
        .HasForeignKey(e => e.BlogId)
        .IsRequired();
Or
        modelBuilder.Entity<FeedbackComment>()
        .HasOne(e => e.Feedback)
        .WithMany(e => e.Comments)
        .HasForeignKey(e => e.FeedbackId)
        .IsRequired();


************1 to 1 relationship**************

// Principal (parent)
public class Blog
{
    public int Id { get; set; }
    public BlogHeader? Header { get; set; } // Reference navigation to dependent
}

// Dependent (child)
public class BlogHeader
{
    public int Id { get; set; }
    public int BlogId { get; set; } // Required foreign key property
    public Blog Blog { get; set; } = null!; // Required reference navigation to principal
}

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .HasOne(e => e.Header)
        .WithOne(e => e.Blog)
        .HasForeignKey<BlogHeader>(e => e.BlogId)
        .IsRequired();
}


************Many to Many relationship**************

Cannot be represented with a FK key. Need a join table

public class Post
{
    public int Id { get; set; }
    public List<Tag> Tags { get; } = [];
}

public class Tag
{
    public int Id { get; set; }
    public List<Post> Posts { get; } = [];
}


protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Post>()
        .HasMany(e => e.Tags)
        .WithMany(e => e.Posts);
}


---OR---

public class Post
{
    public int Id { get; set; }
    public List<Tag> Tags { get; } = [];
}

public class Tag
{
    public int Id { get; set; }
    public List<Post> Posts { get; } = [];
}

public class PostTag
{
    public int PostId { get; set; }
    public int TagId { get; set; }
}


protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Post>()
        .HasMany(e => e.Tags)
        .WithMany(e => e.Posts)
        .UsingEntity<PostTag>();
}


All one-to-one and one-to-many relationships are defined by a foreign key on the dependent end that references a primary or alternate key on the principal end. For convenience, this primary or alternate key is known as the "principal key" for the relationship.

TableA
Id        <---- Principal key

TableB
Id
TableAId  <---- Foreign Key

Navigations:
https://learn.microsoft.com/en-us/ef/core/modeling/relationships/navigations
There is no need to make navigations virtual unless they are being used by lazy-loading or change-tracking proxies.


--EF Conventions EntityFramework Conventions Entity Framework Conventions
https://learn.microsoft.com/en-us/ef/core/modeling/relationships/conventions


Mapping Attributes (aka Data Annotations)
https://learn.microsoft.com/en-us/ef/core/modeling/relationships/mapping-attributes

Mapping Attributes override conventions. Mapping Attributes itself can be overriden by Fluent API


public class Post
{
    public int Id { get; set; }

    [Required]
    public string BlogId { get; set; }

    public Blog Blog { get; init; }
}

When using C# nullable reference types, the BlogId property in this example is already non-nullable (since no ?), which means the [Required] attribute will have no affect.


Keyless Entity Types
https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types?tabs=data-annotations

Keyless Entity Types are different from regular entity types in that they:
Cannot have a key defined.
Are never tracked for changes in the DbContext and therefore are never inserted, updated or deleted on the database.


Managing Database Schemas
https://learn.microsoft.com/en-us/ef/core/managing-schemas/


------------------------ Query data
https://learn.microsoft.com/en-us/ef/core/querying/

Entity Framework Core uses Language-Integrated Query (LINQ) to query data from the database


As a general rule, Entity Framework Core attempts to evaluate a query on the server (i.e Database) as much as possible.

 EF Core converts parts of the query into parameters, which it can evaluate on the client side. The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.

EF Core supports partial client (i.e .Net Core Api) evaluation in the top-level projection (essentially, the last call to Select()).

If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.

If EF Core detects an expression, in any place other than the top-level projection (APART FROM SELECT, which can't be translated to the server (i.e Database), then it throws a runtime exception. <----------------------

Note
Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.
Now only allowed in a Select (top level select projection)

Server - Sqlserver
Client - .Net Api

****Client (.net api) evaluation in the top-level projection***

var blogs = context.Blogs                   <--- Done at database
    .OrderByDescending(blog => blog.Rating) <--- Done at database
    .Select( blog => new { Id = blog.BlogId, Url = StandardizeUrl(blog.Url) }) <--- Done at .Net Api since SqlServer has no idea how this is implemented
    .ToList();


public static string StandardizeUrl(string url)
{
    url = url.ToLower();

    if (!url.StartsWith("http://"))
    {
        url = string.Concat("http://", url);
    }

    return url;
}



****Unsupported client evaluation**** https://learn.microsoft.com/en-us/ef/core/querying/client-eval#unsupported-client-evaluation
While client (.Net Api) evaluation is useful, it can result in poor performance sometimes.

StandardizeUrl is a .neyt function. This throws an exception since all the data will need
to be pulled into memory to execute the where clause

var blogs = context.Blogs
    .Where(blog => StandardizeUrl(blog.Url).Contains("dotnet")) <--- exception
    .ToList();




***Explicit client evaluation***

var blogs = context.Blogs
    .AsEnumerable()   <------------------------ loads into memory first
    .Where(blog => StandardizeUrl(blog.Url).Contains("dotnet"))
    .ToList();


https://learn.microsoft.com/en-us/ef/core/querying/client-eval#previous-versions
Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.


https://learn.microsoft.com/en-us/ef/core/querying/tracking
Tracking vs. No-Tracking Queries

Tracking behavior controls if Entity Framework Core keeps information about an entity instance in its change tracker.

If an entity is tracked, any changes detected in the entity are persisted to the database during SaveChanges.

Note:
Keyless entity types are never tracked. Wherever this article mentions entity types, it refers to entity types which have a key defined.


By default, queries that return entity types are tracking.

EF Core doesn't overwrite current and original values of the entity's properties in the entry with the database values.


No-tracking queries (faster. entities not tracked by EF)

var blogs = context.Blogs
    .AsNoTracking()  <-- results of this query will not be tracked
    .ToList();


No-tracking queries are useful when the results are used in a read-only scenario.

They're generally quicker to execute because there's no need to set up the change tracking information.

A no-tracking query also give results based on what's in the database disregarding any local changes or added entities.
****No cached results unlike EFcore tracking queries***** Gives data from database.

No-tracking queries:
 Don't use the change tracker and don't do identity resolution.
 Return a new instance of the entity even when the same entity is contained in the result multiple times.

Even when using projections, Blog entity type is still tracked
var blog = context.Blogs
    .Select(
        b =>
            new { Blog = b, PostCount = b.Posts.Count() });



If the result set doesn't contain any entity types, then no tracking is done.
var blog = context.Blogs
    .Select(
        b =>
            new { Id = b.BlogId, b.Url });

EF Core doesn't track the keyless entity instances contained in the result.



https://learn.microsoft.com/en-us/ef/core/querying/related-data/eager#eager-loading
Eager loading

using (var context = new BloggingContext())
{
    var blogs = context.Blogs
        .Include(blog => blog.Posts)   <---- You can use the Include method to specify related data to be included in query results.
        .ToList();
}

If you project to an anonymous object, then it won't be tracked by EF

var blogs = ctx.Blogs
    .Select(b => new   <-- Blog not tracked. Copilot
    {
        b.Id,
        b.Name,
        b.Posts
    })
    .ToList();


•If you have a DbSet<PersonPhoto> property defined in your DbContext class, you can directly use context.PersonPhoto.
•If you do not have a DbSet<PersonPhoto> property defined in your DbContext class, you can use the Set<TEntity>() method to access the DbSet for the PersonPhoto entity.

var query = from photo in context.Set<PersonPhoto>()   <-- if no DbSet is defined in context class
            join person in context.Set<Person>()
                on photo.PersonPhotoId equals person.PhotoId
            select new { person, photo };


Regardless of the pagination method used, always make sure that your ordering is fully unique. For example, if results are ordered only by
date, but there can be multiple results with the same date, then results could be skipped when paginating as they're ordered differently
across two paginating queries.


-------Pagination
https://learn.microsoft.com/en-us/ef/core/querying/pagination

Offset pagination -
var position = 20;
var nextPage = context.Posts
    .OrderBy(b => b.PostId)
    .Skip(position)
    .Take(10)
    .ToList();


Keyset pagination  -  Next and Previous only butons. No direct page access ( but does not support random access, where the user can jump to any specific page)
var lastId = 55;
var nextPage = context.Posts
    .OrderBy(b => b.PostId)
    .Where(b => b.PostId > lastId)  <----
    .Take(10)
    .ToList();


If random access pagination is necessary, a robust implementation could use keyset pagination when navigation to the next/previous page,
and offset navigation when jumping to any other page.

Pagination reference links:
https://use-the-index-luke.com/no-offset
https://www.youtube.com/watch?v=DIKH-q-gJNU
https://www.slideshare.net/slideshow/p2d2-pagination-done-the-postgresql-way/22210863


SQL Queries <---------------------------------------------------------------Important----------
https://learn.microsoft.com/en-us/ef/core/querying/sql-queries

Entity Framework Core allows you to drop down to SQL queries when working with a relational database.

SQL queries are useful
1) if the query you want can't be expressed using LINQ, OR
2) if a LINQ query causes EF to generate inefficient SQL.

var blogs = context.Blogs
    .FromSql($"SELECT * FROM dbo.Blogs")
    .ToList();


The FromSql and FromSqlInterpolated methods are safe against SQL injection, and always integrate parameter data as a separate SQL parameter.

FromSqlRaw issue in dynamic queries: https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#dynamic-sql-and-parameters

However, the FromSqlRaw method can be vulnerable to SQL injection attacks, if improperly used. <---?
Be very careful when using FromSqlRaw, and always make sure values are either from a safe origin, or are properly sanitized. SQL injection attacks can have disasterous consequences for your application.


SqlQuery or SqlQueryRaw or  FromSql Or FromSqlRaw?  <--------------------------------------------

•	FromSqlRaw:
•	Context: Used with DbSet<TEntity>.
•	Purpose: Execute raw SQL queries that return entity types <-----
•	Example: context.AdvConvDashboardResponseRecords.FromSqlRaw("EXEC dbo.GetAdvConvDashboardResponseRecords").ToList();

•	SqlQuery:
•	Context: Used with DbContext.
•	Purpose: Execute raw SQL queries that return non-entity types (available in EF Core 7.0+).
•	Example: context.SqlQuery<AdvConvDashboardResponseRecords>("EXEC dbo.GetAdvConvDashboardResponseRecords").ToList();

•	SqlQueryRaw:
•	Context: Used with DbContext.
•	Purpose: Execute parameterized raw SQL queries that return non-entity types (available in EF Core 7.0+).
•	Example: context.SqlQueryRaw<AdvConvDashboardResponseRecords>("EXEC dbo.GetAdvConvDashboardResponseRecords @param1", new SqlParameter("@param1", value)).ToList();

Using FromSqlRaw to execute sproc example but using SqlParameter to make it safe (safe parameterization) <-----------------------
https://www.yogihosting.com/stored-procedures-entity-framework-core/


FromSql (composing with LINQ)

var searchTerm = "Lorem ipsum";

The following example uses a SQL query that selects from a Table-Valued Function (TVF). And then composes on it
using LINQ to do filtering and sorting.

var blogs = context.Blogs
    .FromSql($"SELECT * FROM dbo.SearchBlogs({searchTerm})")
    .Where(b => b.Rating > 3)
    .OrderByDescending(b => b.Rating)
    .ToList();


Sprocs
https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#including-related-data

SQL Server doesn't allow composing over stored procedure calls, so any attempt to apply additional query operators to such a call
will result in invalid SQL. Use AsEnumerable or AsAsyncEnumerable right after FromSql or FromSqlRaw to make sure that EF Core doesn't
try to compose over a stored procedure.


 using (var context = new MyDbContext())
 {
     // Define the parameter
     var param1 = new SqlParameter("@param1", "someValue");

     // Execute stored procedure with the parameter
     var results = context.AdvConvDashboardResponseRecords
         .FromSqlRaw("EXEC SprocA @param1", param1)
         .AsEnumerable()
         .ToList();

     foreach (var record in results)
     {
         Console.WriteLine($"AUM Range: {record.AumRange}, AUM Opportunity: {record.AumOpportunity}, Clients: {record.Clients}, Avg ROA: {record.ROA_Avg}");
     }
 }

var ids = context.Database
    .SqlQuery<int>($"SELECT [BlogId] FROM [Blogs]")
    .ToList();


using (var context = new BloggingContext())
{
    var rowsModified = context.Database.ExecuteSql($"UPDATE [Blogs] SET [Url] = NULL");
}


https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#limitations
Limitations

There are a few limitations to be aware of when returning entity types from SQL queries:
The SQL query must return data for all properties of the entity type.
The column names in the result set must match the column names that properties are mapped to. Note that this behavior is different from EF6;
   EF6 ignored property-to-column mapping for SQL queries, and result set column names had to match those property names.
The SQL query can't contain related data. However, in many cases you can compose on top of the query using the Include operator to return
   related data (see Including related data).

UseNoTracking

----Database Functions
https://learn.microsoft.com/en-us/ef/core/querying/database-functions

Can use FromSqlRaw to execute Sql Server functions.
Make sure to use no tracking to disable entity tracking


Always validate user input: While EF Core protects against SQL injection attacks by using parameters and escaping literals in queries,
it does not validate inputs. Appropriate validation, per the application's requirements, should be performed before values from
un-trusted sources are used in LINQ queries, assigned to entity properties, or passed to other EF Core APIs. This includes any user
input used to dynamically construct queries. Even when using LINQ, if you are accepting user input to build expressions, you need to
make sure that only intended expressions can be constructed

----Saving Data

Approach 1: SaveChanges
Approach 2: ExecuteUpdate and ExecuteDelete ("bulk update")

Note: context.SaveChanges();
For most database providers, SaveChanges is transactional.  <---------------By Default, context.SaveChanges() is Transactional
This means all the operations either succeed or fail and the operations are  never be left partially applied.


Database Transaction explicit. Note above context.SaveChanges()  is transactional

using (var transaction = context.Database.BeginTransaction())
{
    context.Blogs.ExecuteUpdate(/* some update */);
    context.Blogs.ExecuteUpdate(/* another update */);

    ...
}


---Transactions   <-------------------
https://learn.microsoft.com/en-us/ef/core/saving/transactions

custom transaction code

using var context = new BloggingContext();
using var transaction = context.Database.BeginTransaction();

try
{
    context.Blogs.Add(new Blog { Url = "http://blogs.msdn.com/dotnet" });
    context.SaveChanges();

    context.Blogs.Add(new Blog { Url = "http://blogs.msdn.com/visualstudio" });
    context.SaveChanges();

    var blogs = context.Blogs
        .OrderBy(b => b.Url)
        .ToList();

    // Commit transaction if all commands succeed, transaction will auto-rollback
    // when disposed if either commands fails
    transaction.Commit();
}
catch (Exception)
{
    // TODO: Handle failure
}


You can also share a transaction across multiple context instances.
To share a transaction, the contexts must share both a DbConnection and a DbTransaction


Soft Deletes: https://learn.microsoft.com/en-us/ef/core/saving/disconnected-entities#handling-deletes

------- Change Tracking
https://learn.microsoft.com/en-us/ef/core/change-tracking/

Each DbContext instance tracks changes made to entities.

Entity instances become tracked when they are:
 Returned from a query executed against the database
 Explicitly attached to the DbContext by Add, Attach, Update, or similar methods
 Detected as new entities connected to existing tracked entities


Asynchronous Programming
https://learn.microsoft.com/en-us/ef/core/miscellaneous/async

Connection Resiliency
https://learn.microsoft.com/en-us/ef/core/miscellaneous/connection-resiliency
Connection resiliency automatically retries failed database commands


ConnectionStrings
https://learn.microsoft.com/en-us/ef/core/miscellaneous/connection-strings

In ASP.NET Core the configuration system is very flexible, and the connection string could be stored in appsettings.json,
an environment variable, the user secret store, or another configuration source.


Change Tracking  <------------------------------------------------------------- TODO
https://learn.microsoft.com/en-us/ef/core/change-tracking/


DbContext is designed to represent a short-lived unit-of-work, as described in DbContext Initialization and Configuration.

This means that disposing the DbContext is the normal way to stop tracking entities.

In other words, the lifetime of a DbContext should be:
 Create the DbContext instance
 Track some entities
 Make some changes to the entities
 Call SaveChanges to update the database
 Dispose the DbContext instance


Entity states
Every entity is associated with a given EntityState:

-Detached entities are not being tracked by the DbContext.
 var newBlog = new Blog();
 Debug.Assert(context.Entry(newBlog).State == EntityState.Detached);

-Unchanged entities have not been changed since they were queried from the database. All entities returned from queries are initially in this state.
 after savechanges. state will be reset to unchanged

-Added entities are new and have not yet been inserted into the database. This means they will be inserted when SaveChanges is called.
-Modified entities have been changed since they were queried from the database. This means they will be updated when SaveChanges is called.
-Deleted entities exist in the database, but are marked to be deleted when SaveChanges is called.

EF Core tracks changes at the property level. For example, if only a single property value is modified, then
a database update will change only that value. However, properties can only be marked as modified when the
entity itself is in the Modified state. (Or, from an alternate perspective, the Modified state means that
at least one property value has been marked as modified.)


Call ChangeTracker.HasChanges() to determine whether any changes have been made that will cause SaveChanges to make updates to
the database. If HasChanges return false, then SaveChanges will be a no-op.


Entities can be explicitly "attached" to a DbContext such that the context then tracks those entities. This is primarily useful when:

Creating new entities that will be inserted into the database.
Re-attaching disconnected entities that were previously queried by a different DbContext instance.

By default, integer and GUID key properties are configured to use automatically generated key values.


Blog.id is generated in database

context.Add(
    new Blog
    {
        Name = ".NET Blog",



when we add this it is given a temporary id eg Id: -2147482644 PK Temporary

https://learn.microsoft.com/en-us/ef/core/change-tracking/explicit-tracking#explicit-key-values-1
Entities returned from queries are tracked in the Unchanged state

// Attach will add the entity with Unchanged state.
context.Attach(
    new Blog { Id = 1, Name = ".NET Blog", });

There are four main APIs for accessing entities tracked by a DbContext:

DbContext.Entry returns an EntityEntry<TEntity> instance for a given entity instance.
ChangeTracker.Entries returns EntityEntry<TEntity> instances for all tracked entities, or for all tracked entities of a given type.
DbContext.Find, DbContext.FindAsync, DbSet<TEntity>.Find, and DbSet<TEntity>.FindAsync find a single entity by primary key, first looking in tracked entities, and then querying the database if needed.
DbSet<TEntity>.Local returns actual entities (not EntityEntry instances) for entities of the entity type represented by the DbSet.


For each tracked entity, Entity Framework Core (EF Core) keeps track of:

The overall state of the entity. This is one of Unchanged, Modified, Added, or Deleted; see Change Tracking in EF Core for more information.
The relationships between tracked entities. For example, the blog to which a post belongs.
The "current values" of properties.  <-----------
The "original values" of properties, when this information is available. <---------------
  Original values are the property values that existed when entity was queried from the database.
Which property values have been modified since they were queried.
Other information about property values, such as whether or not the value is temporary.

to get above info: https://learn.microsoft.com/en-us/ef/core/change-tracking/entity-entries#using-dbcontextentry-and-entityentry-instances
use context.Entry
var blog = context.Blogs.Single(e => e.Id == 1);  <--- tracked entity
var entityEntry = context.Entry(blog);

The most common use of EntityEntry<TEntity> is to access the current EntityState of an entity. For example:

var currentState = context.Entry(blog).State;
if (currentState == EntityState.Unchanged)
{
    context.Entry(blog).State = EntityState.Modified;
}


The Entry method can also be used on entities that are not yet tracked. This does not start tracking the
entity; the state of the entity is still Detached


The original value of a property is the value that the property had when the entity was queried from the database

var currentValues = context.Entry(blog).CurrentValues;
var originalValues = context.Entry(blog).OriginalValues;
var databaseValues = context.Entry(blog).GetDatabaseValues();

Whenever use Linq queries in the future. see this docs:
https://learn.microsoft.com/en-us/ef/core/change-tracking/

Instead, it performs change detection at specific points, such as when SaveChanges is called

using (var context = new MyDbContext())
{
    var entity = context.MyEntities.First();
    entity.Name = "New Name"; // Direct modification

    // At this point, EF Core has not yet detected the change
    // because DetectChanges has not been called.

    context.SaveChanges(); // DetectChanges is called internally here
}



Methods that automatically detect changes
https://learn.microsoft.com/en-us/ef/core/change-tracking/change-detection#methods-that-automatically-detect-changes

DbContext.SaveChanges and DbContext.SaveChangesAsync, to ensure that all changes are detected before updating the database.
ChangeTracker.Entries() and ChangeTracker.Entries<TEntity>(), to ensure entity states and modified properties are up-to-date.
ChangeTracker.HasChanges(), to ensure that the result is accurate.
ChangeTracker.CascadeChanges(), to ensure correct entity states for principal/parent entities before cascading.
DbSet<TEntity>.Local, to ensure that the tracked graph is up-to-date.

Change Tracking Debug View: https://learn.microsoft.com/en-us/ef/core/change-tracking/debug-views


---------------------------------------------------------------------------------

<-------------- TODOOOOOOOOOOOOOOOOOOOOOOO

Same
.Net Core - Entity Framework: https://learn.microsoft.com/en-us/aspnet/core/getting-started/?view=aspnetcore-8.0
 Data Access > Tutorials (Do with Entity Framework)  <--- TODO
 Tutorials > Data Access (Only applicable to Razor pages  and MVC? Concepts still apply for APIs?)  <--- TODO
             If applicable, do with Entity Framework)

Razor Pages with Entity Framework Core in ASP.NET Core

https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/crud?view=aspnetcore-8.0
Student = await _context.Students
        .Include(s => s.Enrollments)
        .ThenInclude(e => e.Course)
        .AsNoTracking()
        .FirstOrDefaultAsync(m => m.ID == id);

    if (Student == null)
    {
        return NotFound();
    }



An entity may be in one of the following states:

Added: The entity doesn't yet exist in the database. The SaveChanges method issues an INSERT statement.

Unchanged: No changes need to be saved with this entity. An entity has this status when it's read from the database.

Modified: Some or all of the entity's property values have been modified. The SaveChanges method issues an UPDATE statement.

Deleted: The entity has been marked for deletion. The SaveChanges method issues a DELETE statement.

Detached: The entity isn't being tracked by the database context.


sorting, filtering, paging
https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/sort-filter-page?view=aspnetcore-8.0

IQueryable Vs IEnumerable
https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/sort-filter-page?view=aspnetcore-8.0#iqueryable-vs-ienumerable

Calling Contains on an IQueryable is usually preferable for performance reasons. With IQueryable, the filtering is done by
the database server. If an IEnumerable is created first, all the rows have to be returned from the database server.


Data Annotation Attributes List and explanation:
https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-8.0&tabs=visual-studio#the-fullname-calculated-property


By default, EF Core assumes that PK values are generated by the database.

In this tutorial, the fluent API is used only for database mapping that can't be done with attributes. <-------

Used attributes as default and only utilized fluent API what cannot be done with attributes

Some attributes such as MinimumLength can't be applied with the fluent API. MinimumLength doesn't change the schema,
it only applies a minimum length validation rule.


Data Annotations Vs Fluent API  <---------------
https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/complex-data-model?view=aspnetcore-8.0&tabs=visual-studio#fluent-api-alternative-to-attributes

Some developers prefer to use the fluent API exclusively so that they can keep their entity classes clean. Attributes and the
fluent API can be mixed.

There are some configurations that can only be done with the fluent API, for example, specifying a composite PK. There are
some configurations that can only be done with attributes (MinimumLength). The recommended practice for using fluent API or
attributes:

Choose one of these two approaches.
Use the chosen approach consistently as much as possible.


Eager, explicit, and lazy loading <---------------
https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/read-related-data?view=aspnetcore-8.0&tabs=visual-studio#eager-explicit-and-lazy-loading

Concurrency Conflict
https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/concurrency?view=aspnetcore-8.0&tabs=visual-studio#conflict-detection-in-ef-core


Linq Queries - Inheritance
Map inheritance to database
https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/inheritance?view=aspnetcore-8.0



Call a query to return other types
https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/advanced?view=aspnetcore-8.0#call-a-query-to-return-other-types

executing query

public async Task<ActionResult> About()
{
    List<EnrollmentDateGroup> groups = new List<EnrollmentDateGroup>();
    var conn = _context.Database.GetDbConnection();
    try
    {
        await conn.OpenAsync();
        using (var command = conn.CreateCommand())
        {
            string query = "SELECT EnrollmentDate, COUNT(*) AS StudentCount "
                + "FROM Person "
                + "WHERE Discriminator = 'Student' "
                + "GROUP BY EnrollmentDate";
            command.CommandText = query;
            DbDataReader reader = await command.ExecuteReaderAsync();

            if (reader.HasRows)
            {
                while (await reader.ReadAsync())
                {
                    var row = new EnrollmentDateGroup { EnrollmentDate = reader.GetDateTime(0), StudentCount = reader.GetInt32(1) };
                    groups.Add(row);
                }
            }
            reader.Dispose();
        }
    }
    finally
    {
        conn.Close();
    }
    return View(groups);
}

According to Doc, we do not need to write repository and unit of work pattern code.
used to be in old url here: https://learn.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application#the-repository-and-unit-of-work-patterns
but new url removed it: https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/advanced?view=aspnetcore-8.0#create-an-abstraction-layer


https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/advanced?view=aspnetcore-8.0#create-an-abstraction-layer

However, writing additional code to implement these patterns isn't always the best choice for applications that use EF, for several reasons:

The EF context class itself insulates your code from data-store-specific code.


The EF context class can act as a unit-of-work class for database updates that you do using EF.
Eg can add 2 diff entities and call SaveChanges. EF context acts as a unit of work for 2 diff entitites(which would normally
be implemented using different repositories)


EF includes features for implementing TDD without writing repository code. (testing can still do some other way)



Repository and unit of work patterns
https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/advanced?view=aspnetcore-8.0#create-an-abstraction-layer

Explanation
https://learn.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application#the-repository-and-unit-of-work-patterns

The unit of work class coordinates the work of multiple repositories by creating a single database context class shared
by all of them.




Automatic change detection
https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/advanced?view=aspnetcore-8.0#automatic-change-detection

Some of the methods that cause automatic change detection are the following:
 DbContext.SaveChanges
 DbContext.Entry
 ChangeTracker.Entries


EntityFrameworkCore: https://learn.microsoft.com/en-us/ef/core/ -- done
EntityFramework: https://learn.microsoft.com/en-us/ef/          -- done
EF Data: https://learn.microsoft.com/en-us/ef/dotnet-data/      -- done

Using EF 7.0<---
7.0.13

EF videos
5 videos: https://learn.microsoft.com/en-us/shows/entity-framework-core-101/?wt.mc_id=educationalef-c9-niner  soso...
Getting Started with Entity Framework Core: https://www.youtube.com/watch?v=SryQxUeChMc  soso...
Working with an Existing Database: https://www.youtube.com/watch?v=DCYVfLT5_QI soso...
ASP.NET Core Web Apps with EF Core: https://www.youtube.com/watch?v=c-wN-fc594c soso...
Database Providers: https://www.youtube.com/watch?v=moRmKo3nrN4 soso...
Performance Tips: https://www.youtube.com/watch?v=jgESld7U5Bw soso...






.Net Core
   Security and Identity  <------- TODO
    TODO: Use cookie authentication without ASP.NET Core Identity
    https://learn.microsoft.com/en-us/aspnet/core/security/authentication/cookie?view=aspnetcore-8.0



connection string:
For local development, use Secret Manager.  =>
For production deployments, consider using a service like Azure Key Vault.=> AWS Equivalent???

SecretManager in Development: https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-8.0&tabs=windows
Azure Key Vault Production:https://learn.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-8.0
                Azure Key Vault is a cloud-based service that helps safeguard cryptographic keys and secrets used by apps and services.

AWS Equivalent?/


Secret Storage in Development environment: https://learn.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-8.0#secret-storage-in-the-development-environment
Secret Storage in Production environment: https://learn.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-8.0#secret-storage-in-the-production-environment-with-azure-key-vault


https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-8.0&tabs=windows
Never store passwords or other sensitive data in source code.
Production secrets shouldn't be used for development or test. Secrets shouldn't be deployed with the app.
Instead, production secrets should be accessed through a controlled means like environment variables or Azure Key Vault.

Secret Manager (For development purposes only) <====================================== https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-8.0&tabs=windows
The app secrets aren't checked into source control.
 The app secrets are associated with a specific project or shared across several projects.

Warning
The Secret Manager tool doesn't encrypt the stored secrets and shouldn't be treated as a trusted store. It's for development purposes only.
The keys and values are stored in a JSON configuration file in the user profile directory.

Secret Manager tool stores secrets in  %APPDATA%\Microsoft\UserSecrets\<user_secrets_id>\secrets.json
In the preceding file paths, replace <user_secrets_id> with the UserSecretsId value specified in the project file.

Azure Key Vault Production:how to use the Azure Key Vault configuration provider to load app configuration values from Azure Key Vault secret
 Azure Key Vault is a cloud-based service that helps safeguard cryptographic keys and secrets used by apps and services.

-----------------------------------------------Secrets (Passwords etc): Dev Vs Production---------------------------------

1) Secret Storage in Development environment: https://learn.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-8.0#secret-storage-in-the-development-environment
  Set secrets locally using Secret Manager.
  When the sample app runs on the local machine in the Development environment, secrets are loaded from the local user secrets store
  Secret Manager requires a <UserSecretsId> property in the app's project file. Set the property value ({GUID}) to any unique GUID:
  <PropertyGroup>
    <UserSecretsId>{GUID}</UserSecretsId>
  </PropertyGroup>


  passwords, connection strings, or API keys
  Access secrets using IConfiguration

  ***secrets.json file on local computer (Not checked into source control)***
  https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-8.0&tabs=windows
  in appsettings.json, have connectionstring with Password. Remove Password and store it as a secret on local computer.
  Access secret dynamically in code. That way, Password won't be included in source control but can be used in local development
  Developer individually updates the local computer file C:\Users\dalokman\AppData\Roaming\Microsoft\UserSecrets\10ae10b2-6210-4d95-aa7d-f66669c4b651\secrets.json
  file with the password so the app can run.

  In ASP.NET Core, the IConfiguration object aggregates settings from various sources, including appsettings.json,
  appsettings.{Environment}.json, environment variables, and potentially secrets.json (when using user secrets in development).

  To determine the exact source, you can check the appsettings.json file for a section named OctopusApi. If you are using user secrets,
  you can also check the secrets file for the same section.


  var builder = WebApplication.CreateBuilder(args); => calls AddUserSecrets when the EnvironmentName is Development and Secrets are loaded
						       to configuration
  var movieApiKey = builder.Configuration["Movies:ServiceApiKey"];  <== to read settings from secrets.json file (can also look at appSettings.json if secrets.json doesn't have it)

  {
    "Movies": {
      "ServiceApiKey": "12345"
    }
  }

  Priority. 1 has higher priority. If running locally secrets.json file will take precedence over appSettings.json
  1.	Command-line arguments
  2.	Environment variables
  3.	User secrets (only in Development environment) (secrets.json file)
  4.	appsettings.{Environment}.json (e.g., appsettings.Development.json, appsettings.Production.json)
  5.	appsettings.json
  6.	In-memory .NET objects
  7.	Custom providers (e.g., Azure Key Vault, AWS Secrets Manager)



  How do you know which values are needed from secrets. Any project using secrets for local development???

2) Secret Storage in Production environment: https://learn.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-8.0#secret-storage-in-the-production-environment-with-azure-key-vault
   Article is for Azure Key Vault. Will need to know AWS equivalent.

   AWS Secrets Manager:  Stores and manages credentials, such as passwords and connection strings, for applications.
   AWS Key Management Service (KMS):  Manages encryption keys and performs cryptographic operations
   What they hide: Secrets Manager hides credentials, while KMS hides encryption keys.
   How they work: Secrets Manager stores credentials in a vault, while KMS follows the encryption and decryption process.
   How they can be used together: KMS can encrypt the database credentials stored in Secrets Manager. This adds a layer of security in case the Secrets Manager data store is compromised



EF videos
5 videos: https://learn.microsoft.com/en-us/shows/entity-framework-core-101/?wt.mc_id=educationalef-c9-niner

Getting Started with Entity Framework Core: https://www.youtube.com/watch?v=SryQxUeChMc

Working with an Existing Database: https://www.youtube.com/watch?v=DCYVfLT5_QI

ASP.NET Core Web Apps with EF Core: https://www.youtube.com/watch?v=c-wN-fc594c

Database Providers: https://www.youtube.com/watch?v=moRmKo3nrN4

Performance Tips: https://www.youtube.com/watch?v=jgESld7U5Bw





-------------------------------------------------------------------------------------------------------------------------------



-------------------[Dev] .Net Core: Evaluate AutoMapper, Serilog, ClosedXML, Refit-------------------------------

Top-Level Packages: Directly referenced in your .cs project file and managed by you.

Transitive Packages: Indirectly included as dependencies of top-level packages and managed by NuGet.

To check dependencies of a package
      In Installed Tab, Click on package and then on right check Dependencies

To check which package is referencing a transitive package
      Mouse Hover over the transitive package

Use Dapper

Overkill for our project (20 users):
 Only 1 DB so cannot use multiple microservices
 Communicate between microservices using Kafka Or RabbitMQ. Both are messaging systems
 Kafka: how to establish communication between microservices using Kafka in a .NET Core application
 Transactions between databases

---------------------------------------1- Automapper------------------------------------------------
See Bookmark
https://github.com/AutoMapper/AutoMapper
https://www.nuget.org/packages/automapper
https://docs.automapper.org/en/stable/Getting-started.html
https://automapper.org/

first create a map
var configuration = new MapperConfiguration(cfg =>
{
    cfg.CreateMap<Foo, FooDto>();
    cfg.CreateMap<Bar, BarDto>();
});


// use DI (http://docs.automapper.org/en/latest/Dependency-injection.html) or create the mapper yourself
var mapper = configuration.CreateMapper();


Then in your application code, execute the mappings:
var fooDto = mapper.Map<FooDto>(foo);
var barDto = mapper.Map<BarDto>(bar);

https://docs.automapper.org/en/stable/Getting-started.html
If you have a source member called “FirstName”, this will automatically be mapped to a destination member with the name “FirstName”.

AutoMapper also supports Flattening.

Unit Tests to test configuration is valid. Property names match
https://docs.automapper.org/en/stable/Configuration-validation.html#configuration-validation

public class Source
{
	public int SomeValue { get; set; }
}

public class Destination
{
	public int SomeValuefff { get; set; }
}


var configuration = new MapperConfiguration(cfg =>
  cfg.CreateMap<Source, Destination>());

configuration.AssertConfigurationIsValid();



Overriding configuration errors
https://docs.automapper.org/en/stable/Configuration-validation.html#overriding-configuration-errors


Mapping
When source properties don't match destination
we don't need to map property names that do match in source and destination
https://docs.automapper.org/en/stable/Projection.html#projection

Nested Mappings
https://docs.automapper.org/en/stable/Nested-mappings.html

public class OuterSource
{
	public int Value { get; set; }
	public InnerSource Inner { get; set; }
}

public class InnerSource
{
	public int OtherValue { get; set; }
}



We could simply flatten the OuterSource.Inner.OtherValue to one InnerOtherValue property,    <--- flattening

but we might also want to create a corresponding complex type for the Inner property:        <----nested mappings


List and Arrays
https://docs.automapper.org/en/stable/Lists-and-arrays.html

Handling null collections
https://docs.automapper.org/en/stable/Lists-and-arrays.html#handling-null-collections

When mapping a collection property, if the source value is null AutoMapper will map the destination field to an empty
collection rather than setting the destination value to null.


By default will send empty array if source value is null.

to return null collections. The setting can be applied globally and can be overridden per profile and per member with AllowNull and DoNotAllowNull.
var configuration = new MapperConfiguration(cfg => {
    cfg.AllowNullCollections = true;
    cfg.CreateMap<Source, Destination>();
});


Inheritance:
https://docs.automapper.org/en/stable/Lists-and-arrays.html#polymorphic-element-types-in-collections


Complete control over the conversion of one type to another
https://docs.automapper.org/en/stable/Custom-type-converters.html


Null Substitution
https://docs.automapper.org/en/stable/Null-substitution.html#null-substitution

Null substitution allows you to supply an alternate value for a destination member if the source value is null anywhere along the member chain.

var config = new MapperConfiguration(cfg => cfg.CreateMap<Source, Dest>()
    .ForMember(destination => destination.Value, opt => opt.NullSubstitute("Other Value")));


Mapping Inheritance
https://docs.automapper.org/en/stable/Mapping-inheritance.html#mapping-inheritance

Flattening
https://docs.automapper.org/en/stable/Mapping-inheritance.html#mapping-inheritance


AutoMapper maps Entities to DTOs

AOT Rest APi not using Automapper. Still have DTOs and Entities as DTOs and Models
What is the difference between a DTO and a Model? Always execute sproc

Project.Domain
  DTOS
  Models
Project.Data
  Entities   (in future whwn you use Linq. For DB Tables)

AOT Rest Api
 Controllers => Providers => Repository
 DTO & Models
 Common Folder

AOT Rest Api HO Conversion
 Rename all the Providers to Service and put them under  Project.Business > Implementations
 The Services will be configured for DI in IOC

 Project.Api => Project.Business  => Project.Data
 Controller  => Service           => Repository
                Both Service & Respository are configured in IOC for DI

 Execute Sproc in Repository. Mapping do in Service

 Automapper maps between  UI/Domain layers, or Service/Domain layers
 https://docs.automapper.org/en/stable/Getting-started.html#why-use-automapper

 DTOs              under Project.Domain
 Models            under Project.Domain
 Entities/DBModels under Project.Data   (not currently used. Put gitIgnore to have placeholder)

 Current Pages: Repository will send back either DTO or Model
 New Pages (Platform should provide both ways- Execute Sprocs Or Execute Linq Queries):
    1) Linq query execute at Repository. Do mapping of Entities to DTOs in Service layer
    2) Execute Sproc

 Multiple DBcontexts folders +  2 connectionstrings in appsettings <-------

 Project.Data  (keep namespace different for Data1 and Data2 to avoid naming conflicts)
   Data1
     Context
     Custom
     Entities
     Repository
   Data2
     Context
     Custom
     Entities
     Repository

 Can do both ways. Using Sqlconnection with connectionstring (cmcheckdeposits) OR using DbContext

 Migration Purpose: Be able to execute both Sprocs as well as Linq queries.


 ----------------------------------------------------------Serilog---------------------------------------------------

Logs to ELK

0)
using Serilog  (Logs to ELK)  <--------------------------Use this to log to ELK
Log.Warning($"{ApiErrors.RepListContainsUnauthorizedRep}");

Important logs: Eg Error, Warnings  <-----------------


Log to Console & Debug Window
3) Microsoft.Extensions.Logging;
appsettings.development.json shows logging. default logs to console
Console: Logs are written to the console.
Debug: Logs are written to the debug output window (useful during development).

Development see config in appsettings.development.json. What happens in QA and Prod? <--------



------------------------------------------------------------Refit------------------------------------------------------

Refit allows you to call other APIs from your .NET Core Api
eg in Some Api it calls Forgerock, SwaggerHub APis etc

Github: https://github.com/reactiveui/refit

The automatic type-safe REST library for .NET Core, Xamarin and .NET. Heavily inspired by Square's Retrofit library.

Refit turns your REST API into a live interface.

New Templates don't use it <-----

------------------------------------------------------------ClosedXML------------------------------------------------------

ClosedXML =>  (SomeApi uses it) ClosedXML is a .NET library for reading, manipulating and writing Excel 2007+ (.xlsx, .xlsm) files.
It aims to provide an intuitive and user-friendly interface to dealing with the underlying OpenXML API.


https://github.com/ClosedXML/ClosedXML



IHttpContextAccessor httpContextAccessor can be injected because of
services.AddHttpContextAccessor();


In ASP.NET Core, HttpContext is automatically available for dependency injection in your route handlers and
controller actions. You do not need to explicitly set up dependency injection for HttpContext because it is
provided by the framework.
However, if you need to access HttpContext in other parts of your application where it is not directly
available (e.g., in services), you can use IHttpContextAccessor.

--------------------------------------------------API-------------------------------------------

Api: Using Json patch to update partial properties of an object
[HttpPatch("{}")
https://www.youtube.com/watch?v=2MDlJRa4iHs&list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v&index=14


•builder.Services.AddExceptionHandler: Registers services related to exception handling in the DI container
during the service configuration stage.

•app.UseExceptionHandler: Configures the middleware pipeline to handle exceptions during the middleware
configuration stage.

Swagger UI should not load in production
2:50
https://www.youtube.com/watch?v=2MDlJRa4iHs&list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v&index=14

Error Handling
Handling Errors [14 of 18] | Web APIs for Beginners
https://www.youtube.com/watch?v=DkEwPquIurI&list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v&index=15
app.UseExceptionHandler('/error')






--------------Calling other APIs from your API--------------------------------------------

OPen Api Docs (Swagger) can help us 1) debug, 2) document 3) create Api clients (to call other apis)
https://www.youtube.com/watch?v=bgvjOMKOVrM&list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v&index=18

To call other Apis from your Api use Refit or Swaggerclient
Yes, both SwaggerClient and Refit serve the same fundamental purpose:
they help you consume APIs in a .NET application by providing a way to make HTTP requests to API endpoints.

Swaggerclient has an extra generation step


---------------------------------------------------C#----------------------------------------------

C# Video Series: https://www.youtube.com/playlist?list=PLdo4fOcmZ0oVxKLQCHpiUWun7vlJJvUiN

C# Playground - Use .Net 8
  https://dotnetfiddle.net/
C# Versions
  https://www.c-sharpcorner.com/article/c-sharp-versions/
C# Coding Conventions:
  https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions#delegates
C# Docs:
  https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/
C# Language Reference:
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/
Built-in types - C# reference | Microsoft Learn:
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types
C#:
  https://learn.microsoft.com/en-us/dotnet/csharp/
C# List:
  https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-8.0
C# String API:
  https://learn.microsoft.com/en-us/dotnet/api/system.string?view=net-8.0
C#- classes, properties:
  https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-properties
C# built in types:
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types
C# Operators:
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/
C# Switch:
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression
C# is:
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is
C# Linq Operators:
  https://learn.microsoft.com/en-us/dotnet/csharp/linq/get-started/introduction-to-linq-queries#classification-table
Linq Queries:
  https://learn.microsoft.com/en-us/dotnet/csharp/linq/get-started/query-expression-basics
Linq Query Operators:
  https://learn.microsoft.com/en-us/dotnet/csharp/linq/standard-query-operators/
LinQ-All/any:
  https://learn.microsoft.com/en-us/dotnet/csharp/linq/standard-query-operators/quantifier-operations
LINQ overview - .NET | Microsoft Learn:
  https://learn.microsoft.com/en-us/dotnet/standard/linq/


C# Online playground. Select .Net 8
https://dotnetfiddle.net/

To check type in C#

claims is ICollection<Claim>
claimType.GetType()  (Will get runtime type. could be different than parameter type eg if parameter is ICollection<claim> and we pass
it a List<claim>




<==================================Here 3 of 3

C# Reference: https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/
C# Video Series: https://www.youtube.com/playlist?list=PLdo4fOcmZ0oVxKLQCHpiUWun7vlJJvUiN
Linq: https://learn.microsoft.com/en-us/dotnet/standard/linq/

C#:
Doc => https://learn.microsoft.com/en-us/dotnet/csharp/
Videos => https://www.youtube.com/playlist?list=PLdo4fOcmZ0oVxKLQCHpiUWun7vlJJvUiN

Misc: WebApi with .Net core Video Series
https://www.youtube.com/playlist?list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v


https://learn.microsoft.com/en-us/shows/back-end-web-development-with-dotnet-for-beginners/


C#
With C# 12 or above, this class definition can be simplified using a primary constructor:
In C#, The with statement is typically used with record types
 The with statement is useful for working with immutable objects, where you want to create a modified copy without changing the
 original object. <-------------------
In C#, a struct (short for structure) is a value type, not a reference type.

Linq: https://learn.microsoft.com/en-us/dotnet/standard/linq/



C# Reference: https://learn.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/

Var Type
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/#specifying-types-in-variable-declarations
When you declare a variable or constant in a program,
you must either specify its type OR <----------
use the var keyword to let the compiler infer the type.  <--------

You can implicitly type a local variable (but not class members) by using the var keyword. The variable still receives a
type at compile time, but the type is provided by the compiler.

built-in string and object types

All types, including built-in numeric types such as System.Int32 (C# keyword: int), derive ultimately from a
single base type, which is System.Object (C# keyword: object).

This unified type hierarchy is called the Common Type System (CTS).

Each type in the CTS is defined as either a value type or a reference type.


value types : Types that you define by using the struct keyword are value types. all the built-in numeric types are structs
reference types: Types that you define by using the class or record keyword are reference types


Value Type Vs Reference Type
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/#the-common-type-system

value = 2
value2 = value
Value Types (value is copied to value 2. modifying value 2 will not change value 1)
1.  Primitive Types:
      bool
      byte
      char
      decimal
      double
      float
      int
      long
      sbyte
      short
      uint
      ulong
      ushort

2.  Structs:
      DateTime
      TimeSpan
      Guid
      Custom structs defined using the struct keyword

3.  Enumerations:  <-----
      Enums defined using the enum keyword

value = "one"
value2 = value
Reference Types  (both value and value 2 point to the same location. modifying value 2 will change value)

0.  Record
    https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/#reference-types

1.  Classes:
      string  <----
      object
      Custom classes defined using the class keyword

2.  Arrays: <----
      Single-dimensional arrays (e.g., int[])
      Multi-dimensional arrays (e.g., int[,])
      Jagged arrays (e.g., int[][])

3.  Delegates:
      Action
      Func
      Custom delegates defined using the delegate keyword

4.  Interfaces:
      Any interface defined using the interface keyword

5.  Collections:
      List<T>
      Dictionary<TKey, TValue>
      Queue<T>
      Stack<T>
      HashSet<T>
      LinkedList<T>

record types can be either reference types (record class) or value types (record struct).
Record types contain methods that support value-equality.

struct:
A struct is a value type and is typically used for small data structures that contain primarily data and have little
or no behavior.

class:
A class is a reference type and is used for more complex data structures that may contain both data and behavior.

---------------------------------------------record type--------------------------------------------

in C# we cannot modify a record type once its created

In C#, record types are immutable by default, meaning that once an instance of a record is created, its properties
cannot be changed. However, you can create a new instance of a record with modified properties using the with expression.


public record Person(string FirstName, string LastName, int Age)

// Create an instance of the record
var person1 = new Person("John", "Doe", 30);
Console.WriteLine($"Original: {person1}");

// Create a new instance with modified properties using the 'with' expression
var person2 = person1 with { Age = 31 };
Console.WriteLine($"Modified: {person2}");

int number
number.GetType() => System.Int32


There are two categories of value types: struct and enum.

int is a struct

struct can implement interfaces

you can cast a struct type to any interface type that it implements.


Boxing and Unboxing
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing


Boxing
int i = 123;
object o = i;

Unboxing
o = 123;
i = (int)o;


public enum FileMode  <-- Value Type
{
    CreateNew = 1,
    Create = 2,
    Open = 3,
    OpenOrCreate = 4,
    Truncate = 5,
    Append = 6,
}


Reference Types
A type that is defined as a class, record, delegate, array, or interface is a reference type.

string f;  <--- default value is null. (not undefined like JS)


For example, to specify that the value 4.56 should be treated as a float, append an "f" or "F" after the number: 4.56f

If no letter is appended, the compiler infers a type for the literal.

all types derive ultimately from System.Object


anonymous types
It can be inconvenient to create a named type for simple sets of related values that you don't intend to store or pass outside method boundaries.


Primitive Types types can't have a value of null. However, you can create nullable value types by appending a ? after the type.


Compile-time type and run-time type
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/#compile-time-type-and-run-time-type
A variable can have different compile-time and run-time types.

string value both compile-time and run-time types
string message = "This is a string of characters";


compile-time first is object and second is IEnumerable<char>. run-time types first is string and second is IEnumerable<string>
compiler will assign the correct type at runtime

object anotherMessage = "This is another string of characters";
IEnumerable<char> someCharacters = "abcdefghijklmnopqrstuvwxyz";


Use namespaces to organize classes and avoid naming collisions

System.Console.WriteLine("Hello World!");

System is a namespace and Console is a class in that namespace.

The using keyword can be used so that the complete name isn't required, as in the following example:


Implicit Using Directives:
https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives

This means that you can use types defined in these namespaces without having to specify their fully qualified name or manually add a using directive

Microsoft.NET.Sdk
Microsoft.NET.Sdk.Web
Microsoft.NET.Sdk.Worker
Microsoft.NET.Sdk.WindowsDesktop


In modern C# (starting with C# 9.0), you can use top-level statements to simplify the Main method. This allows you to
write the entry point of your application without explicitly defining a Main method. It looks like your Program.cs file
is using this feature.


what are top level statements in C#?

Top-level statements in C# are a feature introduced in C# 9.0 that allow you to write the main entry point of your
application without explicitly defining a Main method. This feature simplifies the code, especially for small
applications or scripts, by allowing you to write code directly at the top level of a file.

namespace SampleNamespace
{
    class SampleClass
    {
        public void SampleMethod()
        {
            System.Console.WriteLine(
                "SampleMethod inside SampleNamespace");
        }
    }
}




Namespaces have the following properties:

They organize large code projects.
They're delimited by using the . operator.
The using directive obviates the requirement to specify the name of the namespace for every class.
The ****global namespace**** is the "root" namespace: global::System will always refer to the .NET System namespace.


https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes#constructors-and-initialization
Beginning with C# 12, you can define a primary constructor as part of the class declaration:

public class Container(int capacity)
{
    private int _capacity = capacity;
}

is equivalent to

public class Container
{
    private int _capacity;

    public Container(int capacity) => _capacity = capacity;
}

The default access for a class type is internal
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes

You can use positional parameters to declare properties of a record and to initialize the property values when you
create an instance:

public record Person(string FirstName, string LastName);  <--- positional parameters

public static void Main()
{
    Person person = new("Nancy", "Davolio");
    Console.WriteLine(person);
    // output: Person { FirstName = Nancy, LastName = Davolio }
}


Anonymous type:
var person = new { FirstName = "Nancy", LastName = "Davolio" };


Record Type:
public record Person(string FirstName, string LastName);
Person person = new("Nancy", "Davolio");

new("Nancy", "Davolio") by itself is not valid C#. It is not anonoymous type

var v = new { Amount = 108, Message = "Hello" }; -> this is anonymous type

You can use a with expression to create a copy of an immutable object with new values in selected properties.

WITH statement---- (record type, structure type or an anonymous type)
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/with-expression
The left-hand operand of a with expression can be of a record type.

Beginning with C# 10, a left-hand operand of a
with expression can also be of a structure type or an anonymous type.

public record NamedPoint(string Name, int X, int Y);

var p1 = new NamedPoint("A", 0, 0);
Console.WriteLine($"{nameof(p1)}: {p1}");  // output: p1: NamedPoint { Name = A, X = 0, Y = 0 }

var p2 = p1 with { Name = "B", X = 5 };
Console.WriteLine($"{nameof(p2)}: {p2}");  // output: p2: NamedPoint { Name = B, X = 5, Y = 0 }


Interfaces
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces
An interface contains definitions for a group of related functionalities that a non-abstract class or a struct must implement.

An interface may define static methods, which must have an implementation.
An interface may define a default implementation for members.
An interface may not declare instance data such as fields, auto-implemented properties, or property-like events.

C# because the language doesn't support multiple inheritance of classes. But can inherit multiple Interfaces

you must use an interface if you want to simulate inheritance for structs, because they can't actually inherit
from another struct or class.

interface IEquatable<T>
{
    bool Equals(T obj);
}

The name of an interface must be a valid C# identifier name. By convention, interface names begin with a capital I.

Interfaces can contain instance methods, properties, events, indexers, or any combination of those four member types.

An interface can't contain instance fields, instance constructors, or finalizers.


Interface members are public by default, and you can explicitly specify accessibility modifiers, such as public,
protected, internal, private, protected internal, or private protected. A private member must have a default implementation.


To implement an interface member, the corresponding member of the implementing class must be public, non-static, and have
the same name and signature as the interface member.

When an interface declares static members, a type implementing that interface may also declare static members with the
same signature.


A class or struct that implements an interface must provide an implementation for all declared members without a
default implementation provided by the interface.

However, if a base class implements an interface, any class that's derived from the base class inherits that implementation.

Interfaces can inherit from one or more interfaces


The derived interface inherits the members from its base interfaces. A class that implements a derived interface must implement all
members in the derived interface, including all members of the derived interface's base interfaces.


Beginning with C# 8.0, an interface may define default implementations for some or all of its members.


Anonymous types
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types

You create anonymous types by using the new operator together with an object initializer.

var v = new { Amount = 108, Message = "Hello" };
Console.WriteLine(v.Amount + v.Message);

Important:
Use var to intialize an anonymous type
Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using var.

Anonymous types are class types that derive directly from object, and that cannot be cast to any type except object.

You can use with statement to copy an object
This enables you to create a new instance of an anonymous type where one or more properties have new values

var apple = new { Item = "apples", Price = 1.35 };
var onSale = apple with { Price = 0.79 };  <--- creates a new object with the same proprties and values with Price overriden


anonymous type used for linq queries

var productQuery =
    from prod in products
    select new { prod.Color, prod.Price }; <----

foreach (var v in productQuery)
{
    Console.WriteLine("Color={0}, Price={1}", v.Color, v.Price);
}

 an anonymous type is no different from any other reference type.

To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare
the parameter as type object. However, using object for anonymous types defeats the purpose of strong typing.
If you must store query results or pass them outside the method boundary, consider using an ordinary named struct
or class instead of an anonymous type.


The accessibility level of an anonymous type is internal, hence two anonymous types defined in different assemblies
are not of the same type.

C# access modifiers
•public: Any code.
•private: Same class.
•protected: Same class and derived classes.
•internal: Same assembly.   <-- default access level for a class
•protected internal: Same assembly or derived classes.
•private protected: Same class or derived classes within the same assembly.

Accesibility. Default is private (https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/#accessibility)
public
protected
internal
protected internal
private
private protected.
The default accessibility is private.

https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/#members
The following list includes all the various kinds of members that may be declared in a class, struct, or record.

Fields
Constants
Properties
Methods
Constructors
Events       <-- Raise event to provide notifications to other classes using delegates
Finalizers   <-- Used to release unmanaged resourced
Indexers
Operators
Nested Types


finalizer
public class ResourceHolder
{
 // Finalizer
 ~ResourceHolder()
 {
    // Release the unmanaged resource
    ReleaseUnmanagedResource();
 }

Events in C# are a way for a class to provide notifications to other classes or objects when something of interest happens. Events are based on delegates and provide a way to implement the observer pattern.



Managed Resources
  eg Objects, arrays, strings
  Automatically managed by the garbage collector.
  Typically do not need explicit cleanup.

Unmanaged Resources:
  eg File handles, database connections, network sockets.
  Require explicit cleanup.
  Should implement IDisposable and provide a finalizer for cleanup.


Inheritance
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/#inheritance
Classes (but not structs) support the concept of inheritance. A class that derives from another class, called the base
class, automatically contains all the public, protected, and internal members of the base class except its constructors
and finalizers.

Classes (but not structs or records) can be declared as static. A static class can contain only static members and can't
be instantiated with the new keyword

C# Object Initializer
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer



Extension Methods
You can "extend" a class without creating a derived class by creating a separate type. That type contains methods that can
be called as if they belonged to the original type. For more information, see Extension methods.
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods


Required
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes
You can also use the required modifier on a property and allow callers to use an object initializer to set the initial value of the property:

public class Person
{
    public required string LastName { get; set; }
    public required string FirstName { get; set; }
}

var p1 = new Person(); // Error! Required properties not set
var p2 = new Person() { FirstName = "Grace", LastName = "Hopper" };


Deep cloning in C#
https://code-maze.com/csharp-deep-copy-of-object/#:~:text=The%20easiest%20way%20to%20create,copy%20of%20the%20original%20object.
https://medium.com/@dayanandthombare/object-cloning-in-c-a-comprehensive-guide-%EF%B8%8F-%EF%B8%8F-d3b79ed6ebcd

Objects:
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/objects


Inheritance
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance

The class whose members are inherited is called the base class, and the class that
inherits those members is called the derived class.

A derived class can have only one direct base class. However, inheritance is transitive.
If ClassC is derived from ClassB, and ClassB is derived from ClassA, ClassC inherits the
members declared in ClassB and ClassA.


Interface declarations may define a default implementation for its members.


These implementations are inherited by derived interfaces, and by classes that implement those interfaces.


When you define a class to derive from another class, the derived class implicitly gains all the
members of the base class, except for its constructors and finalizers. <-------------

constructors aren't inherited

If a base class declares a member as abstract, that method must be overridden in any non-abstract class that directly inherits from that class.

Abstract and virtual methods
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance#abstract-and-virtual-methods


Hide base class members with new members
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/polymorphism#hide-base-class-members-with-new-members

If you want your derived class to have a member with the same name as a member in a base class, you can use the new keyword to hide the base class member.

public class BaseClass
{
    public void DoWork() { WorkField++; }
    public int WorkField;
    public int WorkProperty
    {
        get { return 0; }
    }
}

public class DerivedClass : BaseClass
{
    public new void DoWork() { WorkField++; }
    public new int WorkField;
    public new int WorkProperty
    {
        get { return 0; }
    }
}

A derived class can stop virtual inheritance by declaring an override as sealed.

public class C : B
{
    public sealed override void DoWork() { }
}

OR use new keyword
Sealed methods can be replaced by derived classes by using the new keyword

public class D : C
{
    public new void DoWork() { }
}

Access base class virtual members from derived classes

// Call DoWork on base class
base.DoWork();

-----------------------------------------is expression used for Null checks

The "is expression" supports pattern matching to test an expression and conditionally declare a new
variable to the result of that expression.


int? maybe = 12;

if (maybe is int number)   <------------ testing if 'nullable int' has an int value (and is not null). if so, assign the value to 'number' variable
{
    Console.WriteLine($"The nullable int 'maybe' has the value {number}");
} else
{
    Console.WriteLine("The nullable int 'maybe' doesn't hold a value");
}

The variable number is only accessible and assigned in the true portion of the if clause. <----


if (userInfo is string)

-----check null reference values-----

string? message = ReadMessageOrDefault();

if (message is not null)
{
    Console.WriteLine(message);
}


public static T MidPoint<T>(IEnumerable<T> sequence)
{
    if (sequence is IList<T> list) <--- tests if a variable is non-null and implements the System.Collections.Generic.IList<T> interface.
    {

--(nameof

throw new ArgumentNullException(nameof(sequence), "Sequence can't be null.");

string sequence = "Hello, World!";
Console.WriteLine(nameof(sequence)); // Output: "sequence"


Switch
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching#compare-discrete-values

public State PerformOperation(Operation command) =>
   command switch
   {
       Operation.SystemTest => RunDiagnostics(),
       Operation.Start => StartSystem(),
       Operation.Stop => StopSystem(),
       Operation.Reset => ResetToReady(),
       _ => throw new ArgumentException("Invalid enum value for command", nameof(command)),
   };


The final _ case is a discard pattern that matches all values.

It handles any error conditions where the value doesn't match one of the defined enum values.


string WaterState(int tempInFahrenheit) =>
    tempInFahrenheit switch
    {
        (> 32) and (< 212) => "liquid",
        < 32 => "solid",
        > 212 => "gas",
        32 => "solid/liquid transition",
        212 => "liquid / gas transition",
    };


Reading in csv file with multiple columns
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching#list-patterns


-------------------Discards   _ as its name

https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards

Discards are placeholder variables that are intentionally unused in application code.
Discards are equivalent to unassigned variables; they don't have a value.

You intended to ignore the result of an expression.

A discard indicates that our code never uses the variable.

You indicate that a variable is a discard by assigning it the underscore (_) as its name

simple function in C# that returns a tuple containing two values: an integer and a string.


 public (int, string) GetTuple()  <--- return type tuple: (int, string)
 {
     int number = 42;
     string message = "Hello, World!";
     return (number, message);    <--- returning tuple. can be any number
 }


tuple
In C#, a tuple is a data structure that allows you to store a fixed number of elements of potentially different types.
Tuples are useful for grouping multiple values together without having to define a custom class or struct.


following method call returns a tuple in which the first and second values are discards. area is a previously declared
variable set to the third component returned by GetCityInformation:


var (_, _, area) = city.GetCityInformation(cityName);


Discards are useful in working with tuples when your application code uses some tuple elements but ignores others.


-----------------Deconstruct
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards#tuple-and-object-deconstruction

The Deconstruct method of a class, structure, or interface also allows you to retrieve and deconstruct a specific
set of data from an object.


You can use discards when you're interested in working with only a subset of the deconstructed values

DateTime.TryParse(String, out DateTime)
Because the example is concerned only with validating the date string and not with parsing it to extract
the date, the out argument to the method is a discard.

foreach (string dateString in dateStrings)
{
    if (DateTime.TryParse(dateString, out _))
        Console.WriteLine($"'{dateString}': valid");
    else
        Console.WriteLine($"'{dateString}': invalid");
}


null coalescing operator  ??
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator

The null-coalescing operator ?? returns the value of its left-hand operand if it isn't null; otherwise, it evaluates
the right-hand operand and returns its result.

public static void Method(string arg)
{
    _ = arg ?? throw new ArgumentNullException(paramName: nameof(arg), message: "arg can't be null");

    // Do work with arg.
}


async Task
You want to discard the Task, and ignore any errors generated from that asynchronous operation.

private static async Task ExecuteAsyncMethods()
{
    Console.WriteLine("About to launch a task...");
    _ = Task.Run(() =>
    {
        var iterations = 0;
        for (int ctr = 0; ctr < int.MaxValue; ctr++)
            iterations++;
        Console.WriteLine("Completed looping operation...");
        throw new InvalidOperationException();
    });
    await Task.Delay(5000);
    Console.WriteLine("Exiting after 5 second delay");
}
// The example displays output like the following:
//       About to launch a task...
//       Completed looping operation...
//       Exiting after 5 second delay


Three ways to deconstruct a tuple
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct#tuples

(string city, int population, double area) = QueryCityData("New York City");

You can use the var keyword so that C# infers the type of each variable.
 var (city, population, area) = QueryCityData("New York City");

You can also use the var keyword individually with any or all of the variable declarations inside the parentheses
(string city, var population, var area) = QueryCityData("New York City");

Lastly, you may deconstruct the tuple into variables that have already been declared.

string city = "Raleigh";
int population = 458880;
double area = 144.8;

(city, population, area) = QueryCityData("New York City");

Beginning in C# 10, you can mix variable declaration and assignment in a deconstruction

 string city = "Raleigh";
    int population = 458880;

    (city, population, double area) = QueryCityData("New York City");


Exceptions and Exception Handling
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/

Exception handling using try, catch, and finally

Exceptions are created by using the throw keyword.


Exceptions Overview
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/

Exceptions are types that all ultimately derive from System.Exception.
If you catch System.Exception, rethrow it using the throw keyword at the end of the catch block.


Code in a finally block is executed regardless of if an exception is thrown. Use a finally block to release
resources, for example to close any streams or files that were opened in the try block.

The finally block can be used to release resources such as file streams, database connections, and graphics handles without
waiting for the garbage collector in the runtime to finalize the objects.


Exceptions are represented by classes derived from Exception.


class CustomException : Exception
{
    public CustomException(string message)
    {
    }
}
private static void TestThrow()
{
    throw new CustomException("Custom exception in TestThrow()");
}

A try statement can contain more than one catch block. The first catch statement that can handle the exception is
executed; any following catch statements, even if they're compatible, are ignored.

try
            {
                using (var sw = new StreamWriter("./test.txt"))
                {
                    sw.WriteLine("Hello");
                }
            }
            // Put the more specific exceptions first.
            catch (DirectoryNotFoundException ex)
            {
                Console.WriteLine(ex);
            }
            catch (FileNotFoundException ex)
            {
                Console.WriteLine(ex);
            }
            // Put the least specific exception last.
            catch (IOException ex)
            {
                Console.WriteLine(ex);
            }
            Console.WriteLine("Done");

Because finally blocks are executed even if an exception is thrown, the finally block in the previous example allows
for the file to be closed correctly and helps avoid an error.

Sequence: Try => Catch => Finally

You want to partially handle an exception before passing it on for more handling.

try
{
    // Try to access a resource.
}
catch (UnauthorizedAccessException e)
{
    // Call a custom error logging procedure.
    LogError(e);
    // Re-throw the error.
    throw;
}

You can also specify exception filters to add a boolean expression to a catch clause. Exception filters indicate
that a specific catch clause matches only when that condition is true.


int GetInt(int[] array, int index)
{
    try
    {
        return array[index];
    }
    catch (IndexOutOfRangeException e) when (index < 0)   <---------adding condition to catch block
    {
        throw new ArgumentOutOfRangeException(
            "Parameter index cannot be negative.", e);
    }
    catch (IndexOutOfRangeException e)
    {
        throw new ArgumentOutOfRangeException(
            "Parameter index cannot be greater than the array size.", e);
    }
}

----------------throwing exceptions examples:
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/creating-and-throwing-exceptions


throw new ArgumentException("Parameter cannot be null", nameof(original)      <---  parameter to a method has an invalid value
throw new InvalidOperationException("Logfile cannot be read-only");           <---  An inappropriate call to an object is made, based on the object state.
throw new ArgumentOutOfRangeException("Parameter index is out of range.", e); <---  When an argument to a method causes an exception.

Misc
throw new ArgumentNullException(configKey, $"Missing configuration for {configKey}");
throw new NotImplementedException("Invalid application type");
throw new Exception($"\nMaximum string length in Levenshtein.iLD is
throw new NullReferenceException("Unable to convert anonymous object to a dictionary. The source anonymous object is null.");


1) The method can't complete its defined functionality. For example, if a parameter to a method has an invalid value:
static void CopyObject(SampleClass original)
{
    _ = original ?? throw new ArgumentException("Parameter cannot be null", nameof(original));
}

2) An inappropriate call to an object is made, based on the object state.

public void WriteLog()
    {
        if (!logFile.CanWrite)
        {
            throw new InvalidOperationException("Logfile cannot be read-only");
        }
        // Else write data to the log and return.
    }


3) When an argument to a method causes an exception.

static int GetValueFromArray(int[] array, int index)
{
    try
    {
        return array[index];
    }
    catch (IndexOutOfRangeException e)
    {
        throw new ArgumentOutOfRangeException(
            "Parameter index is out of range.", e);
    }
}


Things to avoid when throwing exceptions
Don't throw System.Exception, System.SystemException, System.NullReferenceException, or System.IndexOutOfRangeException
intentionally from your own source code.


Exceptions in task-returning methods
We recommend that you validate arguments and throw any corresponding exceptions, such as ArgumentException and
ArgumentNullException, before entering the asynchronous parts of your methods.


Compiler-generated exceptions
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/compiler-generated-exceptions


 catch (CustomException)
 {
     throw;  <-- rethrows exception and keeps the stack trace
 }
 catch (Exception ex)
 {
     throw new CustomException(ex, UserFriendlyErrors.GenericError);
 }


Naming Rules
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names#naming-rules

Identifiers must start with a letter or underscore (_).


-----------------------Naming conventions
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names#naming-conventions

By convention, C# programs use PascalCase for type names, namespaces, and all public members.

Interface names start with a capital I.

Attribute types end with the word Attribute.

Enum types use a singular noun for nonflags, and a plural noun for flags.

Identifiers shouldn't contain two consecutive underscore (_) characters. Those names are reserved for compiler-generated identifiers.

Use meaningful and descriptive names for variables, methods, and classes.

Prefer clarity over brevity.

Use PascalCase for class names and method names.

Use camelCase for method parameters and local variables.

Use PascalCase for constant names, both fields and local constants.

Private instance fields start with an underscore (_) and the remaining text is camelCased.

Static fields start with s_. This convention isn't the default Visual Studio behavior, nor part of the Framework design guidelines, but is configurable in editorconfig.

Avoid using abbreviations or acronyms in names, except for widely known and accepted abbreviations.

Use meaningful and descriptive namespaces that follow the reverse domain name notation.

Choose assembly names that represent the primary purpose of the assembly.

Avoid using single-letter names, except for simple loop counters. Also, syntax examples that describe the syntax of C# constructs often use the following single-letter names that match the convention used in the C# language specification. Syntax examples are an exception to the rule.

Use S for structs, C for classes.
Use M for methods.
Use v for variables, p for parameters.
Use r for ref parameters.


C# Coding Conventions
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions



Delegates
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions#delegates


Use Func<> and Action<> instead of defining delegate types. In a class, define the delegate method.

Use Action when You need to perform an operation that takes a string parameter and does not return a value
Action<string> actionExample1 = x => Console.WriteLine($"x is: {x}");

Action<string, string> actionExample2 = (x, y) =>
    Console.WriteLine($"x is: {x}, y is {y}");


Use func when You need to perform an operation that takes a string parameter and returns a value of type TResult.
Func<string, int> funcExample1 = x => Convert.ToInt32(x);

Func<int, int, int> funcExample2 = (x, y) => x + y;


new syntax
var firstExample = new ExampleClass(); is same as ExampleClass instance2 = new();


Use object initializers to simplify object creation, as shown in the following example.
var thirdExample = new ExampleClass { Name = "Desktop", ID = 37414,
    Location = "Redmond", Age = 2.3 };



Use multiple from clauses instead of a join clause to access inner collections. For example, a collection of Student objects
might each contain a collection of test scores. When the following query is executed, it returns each score that is over 90,
along with the last name of the student who received the score.

var scoreQuery = from student in students
                 from score in student.Scores!
                 where score > 90
                 select new { Last = student.LastName, score };



foreach (char ch in laugh)
{
    if (ch == 'h')
    {
        Console.Write("H");
    }
    else
    {
        Console.Write(ch);
    }
}
Console.WriteLine();


C# Casting
•	Direct Cast: (TargetType)object - Use when you are certain of the type.
•	as Operator: object as TargetType - Use for safe casting without exceptions.
•	is Operator: object is TargetType - Use for type checking before casting.
•	Convert.ChangeType: Convert.ChangeType(object, TypeCode) - Use for converting between primitive types.
•	Custom Conversion Methods: Define custom methods for specialized conversion logic.


 null-forgiving operator following a variable name to force the null-state to be not-null.
name!.Length;

https://learn.microsoft.com/en-us/dotnet/csharp/iterators#iterating-with-foreach

Regular foreach
foreach (var item in collection)
{
    Console.WriteLine(item?.ToString());
}

async foreach
await foreach (var item in asyncSequence)
{
Console.WriteLine(item?.ToString());
}


C# Events-------------------------
https://learn.microsoft.com/en-us/dotnet/csharp/events-overview
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/

Events are a way for an object to broadcast (to all interested components in the system) that something has happened.
Any other component can subscribe to the event, and be notified when an event is raised.

public event EventHandler<FileListArgs> Progress;

Invoke
Progress?.Invoke(this, new FileListArgs(file));

Subscribe
EventHandler<FileListArgs> onProgress = (sender, eventArgs) =>
    Console.WriteLine(eventArgs.FoundFile);

fileLister.Progress += onProgress;


// Using GetType to obtain type information:
int i = 42;
Type type = i.GetType();
Console.WriteLine(type);

The output is: System.Int32.


Attribute targets
https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/reflection-and-attributes/#attribute-targets

Expression Trees (later if needed)
https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/expression-trees/

Expression trees represent code in a tree-like data structure, where each node is an expression, for example, a method call or a binary operation such as x < y.

usecase
Certainly! One common use case for using Expression in C# is when you need to build dynamic queries, especially in
scenarios involving LINQ to SQL or Entity Framework. By using expressions, you can construct queries at runtime
based on various conditions.


ref Keyword: Used to pass arguments by reference, allowing the called method to modify the value of the argument.
https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/performance/

out and ref both pass by reference diff

•ref: The variable must be initialized before being passed to the method.
•out: The variable does not need to be initialized before being passed to the method, but the method must assign a value to it.

can pass int via reference as well

string interpolation
https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/string-interpolation

double a = 3;
double b = 4;
Console.WriteLine($"Area of the right triangle with legs of {a} and {b} is {0.5 * a * b}");
Console.WriteLine($"Length of the hypotenuse of the right triangle with legs of {a} and {b} is {CalculateHypotenuse(a, b)}");
double CalculateHypotenuse(double leg1, double leg2) => Math.Sqrt(leg1 * leg1 + leg2 * leg2);
// Output:
// Area of the right triangle with legs of 3 and 4 is 6
// Length of the hypotenuse of the right triangle with legs of 3 and 4 is 5

C# string API
https://learn.microsoft.com/en-us/dotnet/api/system.string?view=net-8.0

string operations
https://learn.microsoft.com/en-us/dotnet/csharp/how-to/compare-strings

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types#the-dynamic-type
dynamic
The dynamic type indicates that use of the variable and references to its members bypass compile-time
type checking. Instead, these operations are resolved at run time.

value type: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types
reference type:

array
int[] array1 = new int[5];
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/arrays

C# Built-in types: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types

And (short circuit)
bool b = true && SecondOperand();  ||
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/boolean-logical-operators

check equality
int a = 1 + 2 + 3;
int b = 6;
Console.WriteLine(a == b);  // output: True

var dict = new Dictionary<string, double>();
dict["one"] = 1;
dict["pi"] = Math.PI;
Console.WriteLine(dict["one"] + dict["pi"]);  // output: 4.14159265358979

default operator
default value
Console.WriteLine(default(int));  // output: 0
Console.WriteLine(default(object) is null);  // output: True

C# Language Reference: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/



switch
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression

	    public static Orientation ToOrientation(Direction direction) => direction switch
    {
        Direction.Up    => Orientation.North,
        Direction.Right => Orientation.East,
        Direction.Down  => Orientation.South,
        Direction.Left  => Orientation.West,
        _ => throw new ArgumentOutOfRangeException(nameof(direction), $"Not expected direction value: {direction}"),
    };



is
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is

int i = 34;
object iBoxed = i;
int? jNullable = 42;
if (iBoxed is int a && jNullable is int b)
{
    Console.WriteLine(a + b);  // output 76
}


if (input is null)
{
    return;
}

if (result is not null)
{
    Console.WriteLine(result.ToString());
}




LINQ
https://learn.microsoft.com/en-us/dotnet/csharp/linq/

Language-Integrated Query (LINQ) is the name for a set of technologies based on the integration of query capabilities directly into
the C# language.


When you write queries, the most visible "language-integrated" part of LINQ is the query expression. Query expressions are written
in a declarative query syntax. By using query syntax, you perform
filtering, ordering, and grouping operations on data sources with a minimum of code.

https://learn.microsoft.com/en-us/dotnet/standard/linq/

// Specify the data source.
int[] scores = [97, 92, 81, 60];

// Define the query expression.
IEnumerable<int> scoreQuery =
    from score in scores
    where score > 80
    select score;


IEnumerable<string> highScoresQuery2 =
    from score in scores
    where score > 80
    orderby score descending
    select $"The score is {score}";

var queryCountryGroups =
    from country in countries
    group country by country.Name[0];

var query = from str in stringArray
            group str by str[0] into stringGroup
            orderby stringGroup.Key
            select stringGroup;

https://learn.microsoft.com/en-us/dotnet/csharp/linq/get-started/features-that-support-linq
var newLargeOrderCustomers = from o in IncomingOrders
                            where o.OrderSize > 5
                            select new Customer { Name = o.Name, Phone = o.Phone };

Anonymous Types
select new {name = cust.Name, phone = cust.Phone};

SelectMany
https://learn.microsoft.com/en-us/dotnet/csharp/linq/standard-query-operators/projection-operations
Projects sequences of values that are based on a transform function and then flattens them into one sequence.


IEnumerable<string> names = from student in students
                            where student.Scores.All(score => score > 70)
                            select $"{student.FirstName} {student.LastName}: {string.Join(", ", student.Scores.Select(s => s.ToString()))}";

foreach (string name in names)
{
    Console.WriteLine($"{name}");
}

// This code produces the following output:
//
// Cesar Garcia: 71, 86, 77, 97
// Nancy Engström: 75, 73, 78, 83
// Ifunanya Ugomma: 84, 82, 96, 80


IEnumerable<string> names = from student in students
                            where student.Scores.Contains(95)
                            select $"{student.FirstName} {student.LastName}: {string.Join(", ", student.Scores.Select(s => s.ToString()))}";

foreach (string name in names)
{
    Console.WriteLine($"{name}");
}

// This code produces the following output:
//
// Claire O'Donnell: 56, 78, 95, 95
// Donald Urquhart: 92, 90, 95, 57


----------------How to create a xUnit Test Project in .Net Core solution and Test with using FakeItEasy?-------------
https://www.youtube.com/watch?v=RgoytbbYbr8&list=PLdo4fOcmZ0oVjOKgzsWqdFVvzGL2_d72v&index=19

FakeItEasy to mock data repository (Instead of FakeItEasy use Moq)
FakeItEasy to mock result returned (Instead of FakeItEasy use Moq)


To run Unit Tests, use View > Test Explorer


--------------------------------------------Unit Testing - XUnit with Moq--------------------------------------------------------


https://github.com/dotnet/EntityFramework.Docs/blob/main/samples/core/Testing/TestingWithTheDatabase/TestDatabaseFixture.cs


Samples

Sample 1: Controllers and their Unit Tests. Open in visual Studio code
Local Folder: C:\Users\dalokman\source\repos\.NetCoreApi-Material\AspNetCore.Docs-main\AspNetCore.Docs-main\aspnetcore\mvc\controllers\testing\samples\3.x\TestingControllersSample
Github: https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/mvc/controllers/testing/samples/3.x/TestingControllersSample

Sample 2: Create Unit Test Data with AutoFixture. Testing Api with MsTest, Moq and Autofixture <--- Good
https://www.youtube.com/watch?v=pLNzz7C2_08 0:58


1) Book: ASP.NET-Core-8-and-Angular   pg 465   (32 pages)
Code: https://github.com/PacktPublishing/ASP.NET-Core-8-and-Angular

2) Book: Web-API-Development-with-ASP.NET-Core-8  pg 333  (75 pages)
Code: https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9

code: https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/blob/main/samples/chapter9/UnitTestsDemo/UnitTest-v1/InvoiceApp/InvoiceApp.WebApi/Services/EmailService.cs
unit test: https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/blob/main/samples/chapter9/UnitTestsDemo/UnitTest-v1/InvoiceApp/InvoiceApp.UnitTests/EmailServiceTests.cs


Unit Testing Controlles
  https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/testing?view=aspnetcore-8.0


Unit Test Resources for
 XUnit
 Moq


Assert.Equal(expected, actual)      Verifies that the expected value is equal to the actual value
Assert.NotEqual(expected, actual)   Verifies that the expected value is not equal to the actual value
Assert.StrictEqual(expected,actual) Verifies that the expected value is strictly equal to the actual value, using the type’s default comparer
Assert.NotStrictEqual(expected, actual)Verifies that the expected value is strictly not equal to the actual value,
                                       using the type’s default comparer
Assert.Same(expected, actual)      Verifies that the expected object is the same instance as the actual object
Assert.NotSame(expected, actual)   Verifies that the expected object is not the same instance as the actual object
Assert.True(condition)             Verifies that the condition is true
Assert.False(condition)            Verifies that the condition is false
Assert.Null(object)                Verifies that the object is null
Assert.NotNull(object)             Verifies that the object is not null


Assert.IsType(expectedType,object)           Verifies that the object is exactly expectedType, and not a derived type
Assert.IsNotType(unexpectedType,object)      Verifies that the object is not exactly unexpectedType
Assert.IsAssignableFrom(expectedType,object) Verifies that the object is assignable to expectedType, which means that object is the given type
                                             or a derived type
Assert.Contains(expected,collection)         Verifies that collection contains the expected object
Assert.DoesNotContain(expected,collection)   Verifies that collection does not contain the expected object
Assert.Empty(collection)                     Verifies that collection is empty
Assert.NotEmpty(collection)                  Verifies that collection is not empty
Assert.Single(collection)                    Verifies that collection contains exactly one element of the given type
Assert.InRange(actual, low, high)            Verifies that the actual value is withinthe range of low and high (inclusive)
Assert.NotInRange(actual, low, high)         Verifies that the actual value is not within the range of low and high (inclusive) Assert.
Throws<exceptionType>(action)                Verifies that action throws an exception of the specified exceptionType, and not a derived
                                             exception type Assert.
ThrowsAny<exceptionType>(action)             Verifies that action throws an exception of the specified exceptionType or a derived exception type

more Assert methods: https://github.com/xunit/assert.xunit


-----------------------------------XUnit

Docs:
  https://xunit.net/docs/getting-started/v2/netcore/visual-studio
  https://xunit.net/#documentation
Attributes & Comparisons with Other Frameoworks
  https://xunit.net/docs/comparisons
XUnit v2 samples:
  https://github.com/xunit/samples.xunit/tree/main/v2
Shared Context between Tests
  https://xunit.net/docs/shared-context
Unit Testing Controllers
  https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/testing?view=aspnetcore-8.0
Unit Testing - Best Practices
  https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices
Rules:
  https://xunit.net/xunit.analyzers/rules/

Moq
  https://github.com/devlooped/moq
Quickstart
  https://github.com/devlooped/moq/wiki/Quickstart


The packages xunit.runner.visualstudio and Microsoft.NET.Test.Sdk are required for being able to run your test
project inside Visual Studio as well as with dotnet test.


Test Explorer
Test Explorer is the name of the window that lets you browse and run your tests from within Visual Studio. Open it by
choosing Test > Test Explorer from the main menu.


TargetFramework specifies the target framework for your test project. By default this will be the latest version of .NET Core that your system supports (in this example, .NET 5.0). Later in this article, we will discuss running tests against multiple target frameworks.
IsPackable is here, though it is redundant (unit test projects cannot be packed by default). You can safely remove this line if you wish.
The xunit package brings in three child packages which include functionality that most developers want: xunit.core (the testing framework itself), xunit.assert (the library which contains the Assert class), and xunit.analyzers (which enables Roslyn analyzers to detect common issues with unit tests and xUnit.net extensibility).
The packages xunit.runner.visualstudio and Microsoft.NET.Test.Sdk are required for being able to run your test project inside Visual Studio as well as with dotnet test.
The coverlet.collector package allows collecting code coverage. If you don't intend to collect code coverage, you should remove this package reference.


[Fact] is an attribute used to denote a test method

No Parameters: Unlike [Theory], which is another attribute in xUnit used for parameterized tests, [Fact] does not take any
parameters. It is used for tests that do not require input data variations.

The third group contains buttons which configure Test Explorer, including advanced options like changing processor
architecture (x86, x64, or Auto) and automatically running tests after every successful build.

xUnit.net includes support for two different major types of unit tests: facts and theories.



[Fact] - Facts are tests which are always true. They test invariant conditions.    -> No Parameters

[Theory] -  Theories are tests which are only true for a particular set of data.   -> With Parameters


The [InlineData(3)] attribute is part of the [Theory] attribute in xUnit, which allows you to run a test method multiple
times with different input data.

Rach theory with its data set is a separate test


By default, each test class is a unique test collection. Tests within the ***same test class*** will not run in parallel against
each other.  <----------------

https://xunit.net/docs/running-tests-in-parallel

Comparing xUnit.net to other frameworks
https://xunit.net/docs/comparisons


***Cannot run in parallel. Same Class***
public class TestClass1
{
    [Fact]
    public void Test1()
    {
        Thread.Sleep(3000);
    }

    [Fact]
    public void Test2()
    {
        Thread.Sleep(5000);
    }
}




***Can run in parallel. Seperate class***
public class TestClass1
{
    [Fact]
    public void Test1()
    {
        Thread.Sleep(3000);
    }
}


public class TestClass2
{
    [Fact]
    public void Test2()
    {
        Thread.Sleep(5000);
    }
}


Shared Context between Tests
https://xunit.net/docs/shared-context

Constructor and Dispose (shared setup/cleanup code without sharing object instances)
Class Fixtures (shared object instance across tests in a single class)
Collection Fixtures (shared object instances across multiple test classes)
Assembly Fixtures (shared object instances across the entire test assembly)


accept any string    value: It.IsAny<string>()
mock.Setup(x => x.DoSomethingStringy(It.IsAny<string>())).Returns((string s) => s.ToLower());

can accept any Bar object passed by reference.
mock.Setup(foo => foo.Submit(ref It.Ref<Bar>.IsAny)).Returns(true);

Resetting between tests
https://github.com/devlooped/moq/wiki/Quickstart#miscellaneous
// Resets setups, configured default return values, registered
// event handlers, and all recorded invocations
mock.Reset();

Moq
  https://github.com/devlooped/moq
Quickstart <--Reference
  https://github.com/devlooped/moq/wiki/Quickstart

Create Unit Test Data with AutoFixture. Testing Api with MsTest, Moq and Autofixture <--- Good
https://www.youtube.com/watch?v=pLNzz7C2_08 0:58



Unit testing best practices with .NET Core and .NET Standard
  https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices

Isolated: Unit tests are standalone, can be run in isolation, and have no dependencies on any outside factors such as a
file system or database.

Try not to introduce dependencies on infrastructure when writing unit tests.

Naming standards are important because they explicitly express the intent of the test.

Test_Single() => Add_SingleNumber_ReturnsSameNumber()

[Fact]
public void Add_EmptyString_ReturnsZero()
{
    // Arrange
    var stringCalculator = new StringCalculator();

    // Act
    var actual = stringCalculator.Add("");

    // Assert
    Assert.Equal(0, actual);
}


Action actual = () => stringCalculator.Add("1001");
Assert.Throws<OverflowException>(actual);


[Theory]
[InlineData("0,0,0", 0)]
[InlineData("0,1,2", 3)]
[InlineData("1,2,3", 6)]
public void Add_MultipleNumbers_ReturnsSumOfNumbers(string input, int expected)
{
    var stringCalculator = new StringCalculator();

    var actual = stringCalculator.Add(input);

    Assert.Equal(expected, actual);
}



Unit Testing controller logic
  https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/testing?view=aspnetcore-8.0

Unit tests involve testing a part of an app in isolation from its infrastructure and dependencies <-------

When unit testing controller logic, only the contents of a single action are tested,  <-------
not the behavior of its dependencies or of the framework itself.

A controller unit test avoids scenarios such as filters, routing, and model binding.

An invalid model state is tested by adding errors using AddModelError as shown in the first test below:
controller.ModelState.AddModelError("SessionName", "Required");


To test (!ModelState.IsValid), add ModelStateError
controller.ModelState.AddModelError("SessionName", "Required");
Passing an invalid model isn't a valid approach, since model binding isn't running

A controller unit test avoids things like filters, routing, or model binding

Don't try to test model validation or model binding in unit tests—just test the action method's behavior when confronted
with an invalid ModelState

mockRepo.Setup(repo => repo.UpdateAsync(testSession))
        .Returns(Task.CompletedTask)
        .Verifiable();

execute method: var result = await controller.Create(newIdea);

// Verify that UpdateAsync method was called
mockRepo.Verify();


1) Book: ASP.NET-Core-8-and-Angular   pg 465   (32 pages)
Code: https://github.com/PacktPublishing/ASP.NET-Core-8-and-Angular

two important dependencies: HttpContext and ApplicationDbContext.

can use Microsoft.EntityFrameworkCore.InMemory for it

https://github.com/PacktPublishing/ASP.NETCore-8-and-Angular/tree/main/Chapter_10/WorldCities


• Arrange: Defines the assets required to run the test
• Act: Invokes the testing subject’s behavior
• Assert: Verifies that the expected conditions are met by evaluating the behavior’s return value, or measuring it against some user-defined rules


page 473 mocking DBcontext Or below
https://github.com/PacktPublishing/ASP.NET-Core-8-and-Angular/blob/main/Chapter_10/WorldCities/WorldCities.Server.Tests/CitiesController_Tests.cs


2) Book: Web-API-Development-with-ASP.NET-Core-8  pg 333  (40 pages)
Code: https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9

Swagger UI that can be used to test the APIs.

var subject = $"Invoice {invoice.InvoiceNumber} for {invoice.Contact.FirstName} {invoice.Contact.LastName}";

C# Raw Literal String. Will preserve spaces etc
var body = $"""

-----Writing unit tests with dependencies   pg 342

code: https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/blob/main/samples/chapter9/UnitTestsDemo/UnitTest-v1/InvoiceApp/InvoiceApp.WebApi/Services/EmailService.cs
unit test: https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/blob/main/samples/chapter9/UnitTestsDemo/UnitTest-v1/InvoiceApp/InvoiceApp.UnitTests/EmailServiceTests.cs

because they are extension methods on top of the ILogger interface. These extension
methods, such as LogInformation(), LogError(), LogDebug(), LogWarning(),
LogCritical(), LogTrace(), and others, all call the Log() method of the ILogger
interface. Therefore, to verify that a given log message is logged, it is necessary to mock only
the Log() method of the ILogger interface.



Assert.Equal(expected, actual)      Verifies that the expected value is equal to the actual value
Assert.NotEqual(expected, actual)   Verifies that the expected value is not equal to the actual value
Assert.StrictEqual(expected,actual) Verifies that the expected value is strictly equal to the actual value, using the type’s default comparer
Assert.NotStrictEqual(expected, actual)Verifies that the expected value is strictly not equal to the actual value,
                                       using the type’s default comparer
Assert.Same(expected, actual)      Verifies that the expected object is the same instance as the actual object
Assert.NotSame(expected, actual)   Verifies that the expected object is not the same instance as the actual object
Assert.True(condition)             Verifies that the condition is true
Assert.False(condition)            Verifies that the condition is false
Assert.Null(object)                Verifies that the object is null
Assert.NotNull(object)             Verifies that the object is not null


Assert.IsType(expectedType,object)           Verifies that the object is exactly expectedType, and not a derived type
Assert.IsNotType(unexpectedType,object)      Verifies that the object is not exactly unexpectedType
Assert.IsAssignableFrom(expectedType,object) Verifies that the object is assignable to expectedType, which means that object is the given type
                                             or a derived type
Assert.Contains(expected,collection)         Verifies that collection contains the expected object
Assert.DoesNotContain(expected,collection)   Verifies that collection does not contain the expected object
Assert.Empty(collection)                     Verifies that collection is empty
Assert.NotEmpty(collection)                  Verifies that collection is not empty
Assert.Single(collection)                    Verifies that collection contains exactly one element of the given type
Assert.InRange(actual, low, high)            Verifies that the actual value is withinthe range of low and high (inclusive)
Assert.NotInRange(actual, low, high)         Verifies that the actual value is not within the range of low and high (inclusive) Assert.
Throws<exceptionType>(action)                Verifies that action throws an exception of the specified exceptionType, and not a derived
                                             exception type Assert.
ThrowsAny<exceptionType>(action)             Verifies that action throws an exception of the specified exceptionType or a derived exception type

more Assert methods: https://github.com/xunit/assert.xunit

pg 348 (We don't use FluentAssertions. Can do same thing with Assert.x)
A good way to make the unit tests more natural and readable is to use FluentAssertions, an open-source assertion library for .NET.
It provides a set of extension methods that allow us to write assertions fluently.
(The FluentAssertions method is more intuitive and readable than the Assert.Equal() method.)

// Omitted code for brevity
returnResult.Should().NotBeNull();
returnResult.Should().HaveCount(2);
// Or use returnResult.Count.Should().Be(2);
returnResult.Should().Contain(i => i.InvoiceNumber == "INV-001");
returnResult.Should().Contain(i => i.InvoiceNumber == "INV-002");

----Microsoft.EntityFrameworkCore.InMemory
The InMemoryDatabase provider was originally designed for internal testing of EF Core.
However, it is not a good choice for testing other applications because it does not behave like a
real database. For example, it does not support transactions and raw SQL queries. So, it is not
a good choice for testing the database access code. <----------------


Also, the DbContext class is already a repository pattern, so creating another repository layer is redundant if you do not need
to change the database provider.  <--- Don't need to use Repository pattern for EF Core   pg 351


pg 351
we will use a separate local database for testing, such as a LocalDB database.

xUnit provides the IClassFixture<T> interface to
create a test fixture, which can be used to prepare and clean up the database for each test class.

We use a lock object to ensure the InitializeDatabase() method is only called once for
each test run.


xUnit creates a new instance of the TestDatabaseFixture test class for every test. So, the constructor of the test class
is called for every test.
public class InvoiceControllerTests(TestDatabaseFixture fixture) : IClassFixture<TestDatabaseFixture>

await dbContext.Database.BeginTransactionAsync();

dbContext.ChangeTracker.Clear();

After the test method is executed, we
do not commit the transaction, so the transaction will roll back.

xUnit uses a concept called test collection to represent a group of tests. By default, each test class is a
unique test collection. Note that the tests in the same test class will not run in parallel.


To do this, we can use the Collection attribute to group these test classes into
one collection so that xUnit will not run them in parallel.

Also, we
should note that the GetInvoicesAsync() method returns IEnumerable<Invoice> instead
of IQueryable<Invoice>.

   public async Task<IEnumerable<Invoice>> GetInvoicesAsync(int page = 1, int pageSize = 10,
        InvoiceStatus? status = null)

pg 369
The repository pattern is a good practice for decoupling the application from the data access layer,
and it also makes it possible to replace the data access layer with another one. It allows us to mock
the database access layer for testing purposes. However, it increases the complexity of the application.
Also, if we use the repository pattern, we may lose some features of EF Core, such as IQueryable.
Finally, the mock behavior may be different from the real behavior. So, we should consider the tradeoffs


What is the difference between as and is in C#?
The as operator is used to perform conversions between compatible types. If the conversion is
not possible, the as operator returns null instead of raising an exception. So, in the preceding
test, if result is not null, we can see that the result from the controller is NotFoundResult,
which is the expected result.
The is operator is used to determine whether an object is compatible with a given type. If the
object is compatible, the operator will return true; otherwise, it will return false. This is a
useful tool for verifying the type of an object before performing an operation on it.
From C# 7, we can use is to check and convert the type at the same time. For example, we
can use if (result is NotFoundResult notFoundResult) to check whether
result is NotFoundResult, and convert it into NotFoundResult at the same time.


3) Entity_Framework_Core_in_Action_Second-SourceCode  pg 525  (36 pages)
Stubbing or mocking an EF Core database (pg 546)

The closest library to mocking EF Core is EF Core’s in-memory database provider.


Book
  ASP.NET-Core-8-and-Angular   pg 465   (32 pages)
  Web-API-Development-with-ASP.NET-Core-8  pg 333  (40 pages)
  Entity_Framework_Core_in_Action_Second-SourceCode  pg 525  (36 pages)

Book: ASP.NET-Core-8-and-Angular   pg 465   (32 pages)
Code: https://github.com/PacktPublishing/ASP.NET-Core-8-and-Angular


According to Doc, we do not need to write repository and unit of work pattern code.
used to be in old url here: https://learn.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application#the-repository-and-unit-of-work-patterns
but new url removed it: https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/advanced?view=aspnetcore-8.0#create-an-abstraction-layer


mocking EF Core with EF Core’s in-memory database provider
Some features cannot be tested with it at all (e.g. transactions, raw SQL..)

https://learn.microsoft.com/en-us/ef/core/testing/

EFCore testing strategy
https://learn.microsoft.com/en-us/ef/core/testing/choosing-a-testing-strategy

1)Using Prod DB
2) Repository pattern
3) Mocking Dbset
4) SQLite in-memory databases.
5) EF Core’s in-memory database provider <--- Discouraged - Avoid the in-memory provider for testing purposes - this is discouraged and only supported for legacy applications.


-------------------------Code coverage- Readme file Minimal APi

install globally
  dotnet tool install --global coverlet.console --version 3.1.0
  dotnet tool install -g dotnet-reportgenerator-globaltool

  dotnet add package coverlet.collector (add only to Unit Test project. execute from the unit test project command prompt)

  generate code coverage: dotnet test --collect:"XPlat Code Coverage"
  TestResults folder will be created with output

  generate report
  reportgenerator -reports:"TestResults\*\coverage.cobertura.xml" -targetdir:"coveragereport" -reporttypes:Html
  (delete if multiple code coverage generated)


Code coverage how check?
coverlet.collector: This is an open-source project that provides code coverage analysis
for .NET applications

Will CI/CD trigger Unit Tests?



Testing with the xUnit Framework - Overview (2 of 12) | Automated Software Testing
  https://www.youtube.com/watch?v=9xBPeRab_MQ    24:33
Testing with the xUnit Framework - Theories and Assertions (3 of 12) | Automated Software Testing
  https://www.youtube.com/watch?v=cWqIW9TG4ss    22:27
Testing with the xUnit Framework - More Assertions (4 of 12) | Automated Software Testing
  https://www.youtube.com/watch?v=JLRNB3nIxHo    18:53
Mocking Dependencies and Verifying Behavior - Moq Overview (6 of 12) | Automated Software Testing
  https://www.youtube.com/watch?v=mmgb4TkiRA4    24:37
Mocking Dependencies and Verifying Behavior - Applying Moq (7 of 12) | Automated Software Testing
  https://www.youtube.com/watch?v=Oqr4klLDzZ4    21:57
Mocking Dependencies & Verifying Behavior-Additional Moq Features (8/12) Automated Software Testing
  https://www.youtube.com/watch?v=mvdFsg67sYI    16:27
Running Tests with Azure Pipelines (9 of 12) | Automated Software Testing ?????
  https://www.youtube.com/watch?v=Ja034np9KhU    29:36
Running Unit Tests with GitHub Actions (10 of 12) | Automated Software Testing
  https://www.youtube.com/watch?v=0lbDMomNt4A    26:39
Integration Testing with SQL Server and EF Core (11 of 12) | Automated Software Testing
  https://www.youtube.com/watch?v=ExbioGgi-aA    19:56



Unit Testing: xUnit
  https://www.youtube.com/watch?v=a7iGLAvekt4    18:08

6 years ago- ok?
 Unit Testing: Moq Framework   38:51
  https://www.youtube.com/watch?v=dZ2Psa_Bn2Q


Moq
  https://www.youtube.com/watch?v=9ZvDBSQa_so   22:09

Moq - 6 years ago? Mocking in C# Unit Tests - How To Test Data Access Code and More
  https://www.youtube.com/watch?v=DwbYxP-etMY   1:02:33


-------------------------------------------------------------------------------------------------------------------




Unhandled exception catch in .net 4.8
Global.asax.cs > Application_EndRequest


Imp Keep DTOs and Model 'same way'. Used Interchangeably. Could have alot of referenced code


public class SomeClass
{
   [JsonProperty("accountNo")]    <----- ***serialized to*** and ***deserialized from*** a JSON property named "accountNo"
   public string accountNo { get; set; }

[JsonProperty("accountNo")]   attribute specifies that the accountNo property in the SomeClass class should be ****serialized to*** and deserialized from a JSON property named "accountNo".


-> is applied both on controller's action method parameter's model validation As well
-> as on saving the property to the database via Entity Framework context.saveChanges (not applicable if executing sprocs)
 [Required]
 public string accountNo { get; set; }


DTO used to send data from API to client as well as receive data from client to API (Can apply [Required] attribute)
Model represents a business Or domain object
Entities represent database tables

•	Model: Represents the business logic and data structure of the application.
•	DTO: Used to transfer data between different layers or systems.


Imp Keep DTOs and Model 'same way'. Used Interchangeably. Could have alot of referenced code


WebApiConfig.cs
     // ignore circular references
     config.Formatters.JsonFormatter.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore;

     // include null properties in serialized json
     config.Formatters.JsonFormatter.SerializerSettings.NullValueHandling = Newtonsoft.Json.NullValueHandling.Include;

     config.Formatters.JsonFormatter.AddQueryStringMapping("$format", "json", "application/json");
     config.Formatters.XmlFormatter.AddQueryStringMapping("$format", "xml", "text/xml");


-----------------------------------------------Error Handling-----------------------------------------

------.net Core .Net 8


2a) Unhandled exception - Ok  Uses ExceptionToProblemDetailsHandler

Status Code: 500 Internal Server Error => Angular 15 should route to Error Page

Response Body
{
    "type": "https://tools.ietf.org/html/rfc9110#section-15.6.1",
    "title": "Internal Server Error",
    "status": 500,
    "detail": "Dan custom exception",
    "instance": "GET /petTest"
}


2b)

Model Binding Issue(send array url = `${url}?category=['fff']`; PetTest to Api when it expects DateTime)

Ok but have to check parameter and send back BadRequest <-------

In ASP.NET Core, the model binder is designed to be forgiving and not throw exceptions when it encounters issues
binding parameters. Instead, it tries to bind as much as it can and assigns default values to parameters it
can't bind. This design choice helps to ensure that your application remains robust and doesn't crash due
to binding issues.

To ensure that the category parameter is correctly bound and to handle cases where it is not provided or is
invalid, you can use a nullable DateTime type (DateTime?). This allows you to check if the parameter was
provided and is valid. If it is not, you can return a meaningful error response.

[HttpGet]
[Route("/petTest")]
public IActionResult PetTest([FromQuery] DateTime? category)  (If send an array to Datetime. .net core will set default value for date and not throw any exception)
{
    if (!category.HasValue)
    {
        // httpStatus 400
        return BadRequest("The 'category' query parameter is required and must be a valid date."); <--TODO
    }


property name casing for serialization/deserialization can be controlled by JsonPropertyName [JsonPropertyName("totalrowcount")]

JsonPropertyName can be applied to class.

Anonymous objects will still be serialized with property naming convention of default serializer System.Text.Json
You'll have to configure policynaming globally or individually?


httpContextAccessor

Default values (if have AssignmentRequestDetails in action method parameters):
  int          : 0
  string       : null
  bool         : false
  List<string> : null
  DateTime     : DateTime.MinValue Or {1/1/0001 12:00:00 AM}
  DateTime?    : null



Binding source parameter inference
Attribute	Binding source
[FromBody]	Request body
[FromForm]	Form data in the request body
[FromHeader]	Request header
[FromQuery]	Request query string parameter  => value is provided in the request URL's query string
[FromRoute]	Route data from the current request
[FromServices]	The request service injected as an action parameter
[AsParameters]	Method parameters   <--- combine parameters to an object

[FromQuery] - Gets values from the query string.
[FromRoute] - Gets values from route data.
[FromForm] - Gets values from posted form fields.
[FromBody] - Gets values from the request body.
[FromHeader] - Gets values from HTTP headers.

[FromServices] is inferred for complex type parameters registered in the DI Container.
[FromBody] is inferred for complex type parameters not registered in the DI Container. An exception to the [FromBody] inference rule is any complex, built-in type with a special meaning, such as IFormCollection and CancellationToken. The binding source inference code ignores those special types.
[FromForm] is inferred for action parameters of type IFormFile and IFormFileCollection. It's not inferred for any simple or user-defined types.
[FromRoute] is inferred for any action parameter name matching a parameter in the route template. When more than one route matches an action parameter, any route value is considered [FromRoute].
[FromQuery] is inferred for any other action parameters.
[FromBody] isn't inferred for simple types such as string or int. Therefore, the [FromBody] attribute should be used for simple types when that functionality is needed.



  call from UI


--------------------------------------------------------------------------------------------------------



Custom DateTime Converter:
• Read Method: Called during deserialization (JSON to C# object) when the API receives a JSON payload.
• Write Method: Called during serialization (C# object to JSON) when the API sends a JSON response.

In .NET 8.0, the default JSON serializer (System.Text.Json) is stricter about date formats compared to the older Newtonsoft.Json
used in .NET 4.8. The default System.Text.Json serializer expects dates in the ISO 8601 format.


Try keeping System.Text.Json (default serializer). Last option to swap to Newtonsoft.Json

***Differences between System.Text.Json and Newtonsoft.Json***

There are several differences between System.Text.Json and Newtonsoft.Json (also known as Json.NET) in terms of features, behavior, and configuration. Here are some key differences:
1. Default Property Naming Policy:
•	System.Text.Json: Uses camelCase naming by default.   <-------- can put in JsonpropertyName attribute
•	Newtonsoft.Json: Uses the property names as defined in the C# class by default.

2. DateTime Handling:     <--------------- use a custom converter
•	System.Text.Json: Expects ISO 8601 format for DateTime and DateTimeOffset.
•	Newtonsoft.Json: More flexible with date formats and can handle various date formats out of the box.

3. Null Value Handling:   <--------------- configure Serialization Options System.Text.Json in Program.cs - Done
•	System.Text.Json: Ignores null values by default during serialization.
•	Newtonsoft.Json: Serializes null values by default.

4. Comments in JSON:
•	System.Text.Json: Does not support comments in JSON.
•	Newtonsoft.Json: Supports comments in JSON when JsonReader and JsonWriter settings are configured to allow them.

5. Reference Handling:
•	System.Text.Json: Does not support preserving object references.
•	Newtonsoft.Json: Supports preserving object references using PreserveReferencesHandling.

6. Polymorphic Serialization:
•	System.Text.Json: Limited support for polymorphic serialization and deserialization.
•	Newtonsoft.Json: Extensive support for polymorphic serialization and deserialization using attributes like JsonConverter.

7. Custom Converters:
•	System.Text.Json: Requires custom converters to be implemented using JsonConverter<T>.
•	Newtonsoft.Json: Custom converters can be implemented using JsonConverter and are generally more flexible.

8. Case Sensitivity:
•	System.Text.Json: Case-sensitive by default.
•	Newtonsoft.Json: Case-insensitive by default.

9. Serialization Attributes:
•	System.Text.Json: Uses attributes like [JsonPropertyName], [JsonIgnore], and [JsonConverter].
•	Newtonsoft.Json: Uses attributes like [JsonProperty], [JsonIgnore], and [JsonConverter].

10. Performance:
•	System.Text.Json: Generally faster and more memory-efficient, especially for simple scenarios.
•	Newtonsoft.Json: More feature-rich but can be slower and more memory-intensive.

11. Indented Formatting:
•	System.Text.Json: Uses JsonSerializerOptions.WriteIndented for indented formatting.
•	Newtonsoft.Json: Uses Formatting.Indented for indented formatting.

12. Handling of Additional Properties:
•	System.Text.Json: Ignores additional properties by default during deserialization.
•	Newtonsoft.Json: Can handle additional properties using JsonExtensionData.

13. Default Values:
•	System.Text.Json: Ignores default values during serialization.
•	Newtonsoft.Json: Serializes default values by default.

14. Enums:
•	System.Text.Json: Serializes enums as their numeric values by default.
•	Newtonsoft.Json: Serializes enums as their string names by default.

15. Circular References:
•	System.Text.Json: Does not support handling circular references.
•	Newtonsoft.Json: Supports handling circular references using ReferenceLoopHandling.

Summary:
While System.Text.Json is optimized for performance and is the default JSON library in .NET Core 3.0 and later, Newtonsoft.Json remains more feature-rich and flexible, making it suitable for complex scenarios. Depending on your specific needs, you may choose one over the other or even use both in the same project for different purposes.

--------------------------------------------------------------------------------------------------------


TODO
how to send these in .Net Core. Used in .net 4.8
HttpStatusCode.OK                   200

HttpStatusCode.Forbidden            403
HttpStatusCode.InternalServerError  500
HttpStatusCode.BadRequest           400  -- done
HttpStatusCode.Unauthorized         401

Custom how
HttpStatusCode.NotFound             404
HttpStatusCode.RequestTimeout       408


See Full Status Code List below search 'public enum HttpStatusCode'



**VPC (Virtual Private Cloud)**
A VPC is a logically isolated section of AWS where you can launch AWS resources like EC2 instances (web server in cloud),
in a virtual network that you define.

You have control over the network settings, including IP address ranges, subnets, route tables, and gateways.

It allows you to segment resources for security, performance, and compliance by keeping them isolated from other AWS account


**Clusters**
In AWS, a cluster generally refers to a group of computing resources managed together. Two common examples are
1) ECS (ElasticContainer Service)-group of EC2 instances

2) EKS Cluster (Elastic Kubernetes Service)
A fully managed service* to run Kubernetes on AWS. It allows you to manage and orchestrate *containerized* applications using
Kubernetes, and the cluster helps in scaling and managing resources efficiently

managed service*  AWS operates and maintains on behalf of customers reducing the need for users to manage the underlying
infrastructure or perform routine tasks like patching, scaling and backups

----------------------------------------------------Sprocs/Stored Procedure Execution-------------------------------------------------

Ref:
https://www.yogihosting.com/stored-procedures-entity-framework-core/
https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/advanced?view=aspnetcore-8.0#call-a-query-to-return-other-types
https://learn.microsoft.com/en-us/ef/core/querying/sql-queries?tabs=sqlserver
https://learn.microsoft.com/en-us/ef/core/querying/sql-queries?tabs=sqlserver#including-related-data
https://learn.microsoft.com/en-us/ef/core/saving/transactions
https://learn.microsoft.com/en-us/ef/core/saving/



a) Using ADO.Net to execute sproc. Provides complete control over Sql execution
Sprocs Granular control using SqlConnection, SqlCommand, sqlDataReader
  1) riskscorehistoryaws-api     GetRickScoreHistory()
  2) https://www.yogihosting.com/stored-procedures-entity-framework-core/
  3) https://learn.microsoft.com/en-us/aspnet/core/data/ef-mvc/advanced?view=aspnetcore-8.0#call-a-query-to-return-other-types

b) Using EF Core to execute sproc


Use Dapper to execute Sprocs


await _connection.QueryAsync<someClass>("sprocname", parameters, commandType: CommandType.StoredProcedure);




 ***Sproc that returns multiple record sets***
 https://www.yogihosting.com/stored-procedures-entity-framework-core/
 Remember that the .FromSqlRaw() method gets only one record set from a stored procedure. If the Stored procedure returns multiple record
 sets then use the ExecuteReader() method.



Note: context.SaveChanges();
For most database providers, SaveChanges is transactional.  <---------------By Default, context.SaveChanges() is Transactional
This means all the operations either succeed or fail and the operations are  never be left partially applied.


Use AsNoTracking when executing Sprocs since don't need entities to be tracked by EF. More faster
Sprocs used for CRUD=> create, read, update and delete

var results = context.AdvConvDashboardResponseRecords
    .FromSqlRaw("EXEC dbo.GetAdvConvDashboardResponseRecords")
    .AsNoTracking()  <-----------------------------------------------------------
    .ToList();


As a general rule, Entity Framework Core attempts to evaluate a query on the server (DB) as much as possible.

While client (API) evaluation is useful, it can result in poor performance sometimes.


Even if the result type of the query isn't an entity type, EF Core will still track entity types contained in the result by default

Below is still tracked
var blog = context.Blogs
    .Select(
        b =>
            new { Blog = b, PostCount = b.Posts.Count() }); <-- still tracked since Blog is an entity

Below is not tracked since result type is not an entity
var blog = context.Blogs
    .Select(
        b =>
            new { Id = b.BlogId, b.Url });

FromSqlRaw/FromSqlInterpolated methods must return all the columns mapped to the entity calls

downside of Dapper is that it doesn’t know anything about navigational properties, so working with linked entities
takes more code in Dapper than it does in EF Core


When we use the FromSql() or FromSqlRaw() methods, keep in mind that there are some limitations:
• The data returned from the SQL query must contain all the properties of the entity, otherwise,
EF Core cannot map the data to the entity.
• The column names returned from the SQL query must match the column names that the entity
properties are mapped to.
• The SQL query can only query one table. If you need to query multiple tables, you can build
the raw query first and then use the Include() method to include the related entities.

Calling Sproc and returning CLR Types- regular classes (that are not part of EF model - context)
https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-8.0/whatsnew#raw-sql-queries-for-unmapped-types

Types used in this way do not have keys defined and cannot have relationships to other types. Types with relationships
must be mapped in the model.

SqlQuery is that it returns an ***IQueryable*** which can be composed on using LINQ. (inline query)
var summariesIn2022 =
    await context.Database.SqlQuery<PostSummary>(
            @$"SELECT b.Name AS BlogName, p.Title AS PostTitle, p.PublishedOn
               FROM Posts AS p
               INNER JOIN Blogs AS b ON p.BlogId = b.Id")
        .Where(p => p.PublishedOn >= cutoffDate && p.PublishedOn < end)
        .ToListAsync();

 var blogNames = context.Database.SqlQuery<string>(
                       "SELECT Name FROM dbo.Blogs").ToList();
The results returned from SqlQuery on Database will never be tracked by the context even if the objects are instances of an entity type.

https://learn.microsoft.com/en-us/ef/ef6/querying/raw-sql

To execute sproc and return clr type (FeeBillingSettingsResponse is not an entity and don't have to include it in EF Model in context. won't be tracked by EF)
await _someContext.Database.SqlQueryRaw<FeeBillingSettingsResponse>(sql, lParams.ToArray())


************Ef Core: mapping nested complex types that are clr types (not entity) as a result of sproc execution*****************
 need 2nd dto object

One common approach is to flatten the result set and then manually map the results to the complex type properties.

public class FBSettingsResponse  (sproc execution need to map to this)
{
    public int Id { get; set; }
    public string Name { get; set; }
    public Address Address { get; set; } // Complex type property
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
    public string ZipCode { get; set; }
}

CREATE PROCEDURE GetFBSettings
    @Category VARCHAR(50)
AS
BEGIN
    SELECT
        Id,
        Name,
        Amount,
        Street,
        City,
        ZipCode
    FROM FBSettings
    LEFT JOIN Address ON FBSettings.AddressId = Address.Id
    WHERE Category = @Category
END

public class FBSettingsResponseDTO
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Amount { get; set; }
    public string Street { get; set; }
    public string City { get; set; }
    public string ZipCode { get; set; }
}

public async Task<List<FBSettingsResponse>> GetFBSettings(string category)
{
    string sproc = 'someSprocName-GetFBSettings';
    string sql = $"EXEC {sproc} @Category";

    var parameters = new[]
    {
        new SqlParameter("@Category", SqlDbType.VarChar) { Direction = ParameterDirection.Input, Value = (object)category ?? DBNull.Value }
    };

    var dtoList = await _someContext.Database.SqlQueryRaw<FBSettingsResponseDTO>(sql, parameters).ToListAsync();

    // Manually map the DTO to the complex type
    var settings = dtoList.Select(dto => new FBSettingsResponse
    {
        Id = dto.Id,
        Name = dto.Name,
        Amount = dto.Amount,
        Address = new Address
        {
            Street = dto.Street,
            City = dto.City,
            ZipCode = dto.ZipCode
        }
    }).ToList();

    return settings;
}


************Ef Core: mapping nested complex types clr object*****************


************Dapper: mapping nested complex types -  do not need 2nd dto object*****************

public class FBSettingsResponse
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Amount { get; set; }
    public Address Address { get; set; } // Complex type property
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
    public string ZipCode { get; set; }
}



CREATE PROCEDURE GetFBSettings
    @Category VARCHAR(50)
AS
BEGIN
    SELECT
        Id,
        Name,
        Amount,
        Street,
        City,
        ZipCode
    FROM FBSettings
    LEFT JOIN Address ON FBSettings.AddressId = Address.Id
    WHERE Category = @Category
END


using Dapper;
using System.Data.SqlClient;
using System.Threading.Tasks;
using System.Collections.Generic;

public class FBSettingsRepository
{
    private readonly string _connectionString;

    public FBSettingsRepository(string connectionString)
    {
        _connectionString = connectionString;
    }

    public async Task<List<FBSettingsResponse>> GetFBSettings(string category)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            string sproc = "GetFBSettings";
            var parameters = new { Category = category };

            var sql = $"EXEC {sproc} @Category";

            var result = await connection.QueryAsync<FBSettingsResponse, Address, FBSettingsResponse>(
                sql,
                (fbSettings, address) =>
                {
                    fbSettings.Address = address;
                    return fbSettings;
                },
                parameters,
                splitOn: "Street"
            );

            return result.AsList();
        }
    }
}

************Dapper: mapping nested complex types End *****************


************Automapper: mapping nested complex types- need 2nd dto object*****************

Install-Package AutoMapper
Install-Package AutoMapper.Extensions.Microsoft.DependencyInjection

public class FBSettingsResponse
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Amount { get; set; }
    public Address Address { get; set; } // Complex type property
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
    public string ZipCode { get; set; }
}

using AutoMapper;

public class MappingProfile : Profile
{
    public MappingProfile()
    {
        CreateMap<FBSettingsResponseDTO, FBSettingsResponse>()
            .ForMember(dest => dest.Address, opt => opt.MapFrom(src => new Address
            {
                Street = src.Street,
                City = src.City,
                ZipCode = src.ZipCode
            }));
    }
}


Register AutoMapper in your Startup.cs or Program.cs:
public void ConfigureServices(IServiceCollection services)
{
    services.AddAutoMapper(typeof(MappingProfile));
    // Other service registrations
}

CREATE PROCEDURE GetFBSettings
    @Category VARCHAR(50)
AS
BEGIN
    SELECT
        Id,
        Name,
        Amount,
        Street,
        City,
        ZipCode
    FROM FBSettings
    LEFT JOIN Address ON FBSettings.AddressId = Address.Id
    WHERE Category = @Category
END

public class FBSettingsResponseDTO
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Amount { get; set; }
    public string Street { get; set; }
    public string City { get; set; }
    public string ZipCode { get; set; }
}


using Dapper;
using AutoMapper;
using System.Data.SqlClient;
using System.Threading.Tasks;
using System.Collections.Generic;

public class FBSettingsRepository
{
    private readonly string _connectionString;
    private readonly IMapper _mapper;

    public FBettingsRepository(string connectionString, IMapper mapper)
    {
        _connectionString = connectionString;
        _mapper = mapper;
    }

    public async Task<List<FBSettingsResponse>> GetFBSettings(string category)
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            string sproc = "GetFBSettings";
            var parameters = new { Category = category };

            var sql = $"EXEC {sproc} @Category";

            var dtoList = await connection.QueryAsync<FBSettingsResponseDTO>(sql, parameters);

            // Use AutoMapper to map the DTO to the complex type
            var settings = _mapper.Map<List<FBSettingsResponse>>(dtoList);

            return settings;
        }
    }
}

Sproc Execution


Dapper

         public async Task<List<ResponseClass>> SomeMethod(string param)
            List<ResponseClass> result = new List<ResponseClass>();

            var parameters = new DynamicParameters();

            parameters.Add("@SomeParam", paramValue, DbType.String, ParameterDirection.Input);

            var resultEnumerable = await _connection.QueryAsync<ResponseClass>(sprocname, parameters, commandType: CommandType.StoredProcedure);
            settings = resultEnumerable.ToList();
            return settings;

EFCore
   List<ResponseClass> result = new List<ResponseClass>();

   string sproc = "SomeSprocName";
   string sql = $"EXEC {sproc} @SomeParam";

   List<SqlParameter> lParams = new List<SqlParameter>();

   lParams.Add(new SqlParameter("@SomeParam", SqlDbType.VarChar) { Direction = ParameterDirection.Input, Value = SomeParam});

   settings = await _dbContext.Database.SqlQueryRaw<ResponseClass>(sql, lParams.ToArray())
                   .ToListAsync();

   return settings;


SqlConnection, SqlCommand and SqlDataReader
   List<ResponseClass> result = new List<ResponseClass>();

    using (SqlConnection connection = new SqlConnection(connectionString))
    {
      await connection.OpenAsync();

      using (SqlCommand command = new SqlCommand(sproc, connection))
      {
         command.CommandType = CommandType.StoredProcedure;
         command.Parameters.Add(new SqlParameter("@SomeParam", SqlDbType.VarChar, 100) { Value = @SomeParam });

         using (SqlDataReader reader = await command.ExecuteReaderAsync())
           {
                       while (await reader.ReadAsync())
                        {
                            var response = new ResponseClass
                            {
                                FirstProperty = Convert.ToInt32(reader["column1"]),
                                SecondProperty = reader["column2"].ToString()!,
                            };

                            result.Add(response);
                        }
                    }
                }
            }

            return result;




HttpStatusCode.OK                   200

HttpStatusCode.Forbidden            403
HttpStatusCode.InternalServerError  500
HttpStatusCode.BadRequest           400  -- done
HttpStatusCode.Unauthorized         401

Custom how
HttpStatusCode.NotFound             404
HttpStatusCode.RequestTimeout       408


Log.Information()
Log.Warning()
Log.Error()


Prefer. Because then can search by orderId in ELK?
_logger.Information("Recieved order {OrderId}", orderId);

Do not use.
_logger.Information($"Recieved order {orderId}");


---------------------------------------------Custom Response End---------------------------------------------

difference between filter and attribute


• Filters: Used to execute code at specific points in the request processing pipeline.
     Authorization Filters (IAuthorizationFilter): Run before any other filters to determine if the user is authorized to access the resource.
     Action Filters (IActionFilter): Run before and after the execution of an action method.
     Exception Filters: Run when an unhandled exception occurs during the execution of an action.

     Implement interfaces like IAuthorizationFilter, IActionFilter,
     Filters can be applied globally, at the controller level, or at the action level. <---


• Attributes: Used to add metadata to code elements.
     Inherits from System.Attribute


Custom Exception Handler using Exception Base class and ActionFilter
